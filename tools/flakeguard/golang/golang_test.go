package golang

import (
	"bufio"
	"encoding/json"
	"errors"
	"os"
	"os/exec"
	"path/filepath"
	"slices"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// Mock version of hasTests function to simulate various scenarios
func mockHasTests(pkgName string) (bool, error) {
	switch pkgName {
	case "pkgWithTests":
		return true, nil
	case "pkgWithoutTests":
		return false, nil
	case "pkgWithError":
		return false, errors.New("test error")
	default:
		return false, nil
	}
}

func TestFilterPackagesWithTests(t *testing.T) {
	t.Parallel()

	// Replace hasTests with mock function
	originalHasTests := hasTests
	hasTests = mockHasTests
	defer func() { hasTests = originalHasTests }() // Restore original function after test

	t.Run("should return packages that contain tests", func(t *testing.T) {
		pkgs := []string{"pkgWithTests", "pkgWithoutTests", "pkgWithError"}
		expected := []string{"pkgWithTests"}

		result := FilterPackagesWithTests(pkgs)

		assert.Equal(t, expected, result, "Expected packages with tests only")
	})

	t.Run("should return an empty slice when all packages have no tests", func(t *testing.T) {
		pkgs := []string{"pkgWithoutTests"}
		expected := []string{}

		result := FilterPackagesWithTests(pkgs)

		assert.Equal(t, expected, result, "Expected empty slice for packages without tests")
	})

	t.Run("should handle error scenarios gracefully", func(t *testing.T) {
		pkgs := []string{"pkgWithError"}
		expected := []string{}

		result := FilterPackagesWithTests(pkgs)

		assert.Equal(t, expected, result, "Expected empty slice for packages with errors")
	})
}

func TestSkipTests(t *testing.T) {
	t.Parallel()

	testRunDir := "./testdata-TestSkipTests"
	err := os.RemoveAll(testRunDir)
	require.NoError(t, err, "Failed to remove test run dir")
	err = os.MkdirAll(testRunDir, 0755)
	require.NoError(t, err, "Failed to create temp dir")
	t.Cleanup(func() {
		if !t.Failed() {
			if err := os.RemoveAll(testRunDir); err != nil {
				t.Fatalf("Failed to remove temp dir: %v", err)
			}
			return
		}
		t.Logf("Skipping cleanup of temp dir %s because test failed, leaving it for debugging", testRunDir)
	})

	// Copy the testdata directory to the temp dir for running the test on
	err = os.CopyFS(testRunDir, os.DirFS("testdata"))
	require.NoError(t, err, "Error copying testdata to temp dir")

	err = filepath.Walk(testRunDir, func(path string, info os.FileInfo, err error) error {
		if err != nil || info.IsDir() {
			return err
		}
		content, err := os.ReadFile(path)
		if err != nil {
			return err
		}
		warning := "// Test code file generated by TestSkipTests; DO NOT EDIT.\n\n"
		return os.WriteFile(path, []byte(warning+string(content)), 0644)
	})

	var (
		expectedPassed = []string{
			"TestPackAPass", "TestPackBPass", "TestPackAFailTrick", "TestPackBFailTrick",
			"TestPackAFailSubTest", "TestPackAFailSubTest/passing_subtest",
		}
		testsToSkip = []*SkipTest{
			{Package: "github.com/owner/repo/testdata/package_a", Name: "TestPackAFail"},
			{Package: "github.com/owner/repo/testdata/package_a", Name: "TestPackAFailSubTest/failing_subtest"},
			{Package: "github.com/owner/repo/testdata/package_b", Name: "TestPackBFail"},
			{Package: "github.com/owner/repo/testdata/package_a", Name: "TestPackASkippedAlready"},
			{Package: "github.com/owner/repo/testdata/package_b", Name: "TestPackBSkippedAlready"},
		}
	)
	slices.Sort(expectedPassed)
	var expectedSkipped []string
	for _, test := range testsToSkip {
		expectedSkipped = append(expectedSkipped, test.Name)
	}
	slices.Sort(expectedSkipped)
	// End setup

	err = SkipTests(testRunDir, testsToSkip)
	assert.NoError(t, err)

	for _, test := range testsToSkip {
		if test.Name == "TestPackASkippedAlready" || test.Name == "TestPackBSkippedAlready" {
			assert.True(t, test.AlreadySkipped, "Expected already skipped test '%s' to already be skipped", test.Name)
			assert.False(t, test.NewlySkipped, "Expected already skipped test '%s' to not be skipped again", test.Name)
		} else {
			assert.True(t, test.NewlySkipped, "Expected flaky test '%s' to be skipped", test.Name)
			assert.False(t, test.AlreadySkipped, "Test '%s' should not have already been skipped", test.Name)
		}
		assert.NoError(t, test.ErrorSkipping, "Expected no error skipping test")
	}

	// Run the tests to make sure only the tests that should be skipped are skipped
	// We're not using flakeguard test runner here to just keep things simple
	cmd := exec.Command("go", "test", "-json", "-count=1", "-v", "./...")
	cmd.Dir = testRunDir
	out, cmdErr := cmd.CombinedOutput()
	testOutputFile := filepath.Join(testRunDir, "test_output.json")
	err = os.WriteFile(testOutputFile, out, 0644)
	require.NoError(t, err, "Error writing test output to file")
	assert.NoError(t, cmdErr, "Tests failed during execution. If tests have been properly skipped, this error should not happen. Look in '%s' for test output", testOutputFile)

	passed, skipped, err := parseTestOutput(t, testOutputFile)
	require.NoError(t, err, "Error parsing test output")

	assert.EqualValues(t, expectedPassed, passed, "Expected certain tests to pass")
	assert.EqualValues(t, expectedSkipped, skipped, "Expected certain tests to be skipped")
}

type goTestOutput struct {
	Package string `json:"package"`
	Test    string `json:"test"`
	Action  string `json:"action"`
	Output  string `json:"output"`
}

// Don't use the other flakeguard parsing as they're too complex for this, and we shouldn't test them here
func parseTestOutput(t *testing.T, jsonFile string) (passed, skipped []string, err error) {
	t.Helper()

	f, err := os.Open(jsonFile)
	if err != nil {
		return nil, nil, err
	}
	defer f.Close()

	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		var event goTestOutput
		line := scanner.Bytes()
		if err := json.Unmarshal(line, &event); err != nil {
			continue // skip lines that aren't test events
		}
		if event.Test == "" {
			continue
		}
		switch event.Action {
		case "run":
		case "pass":
			passed = append(passed, event.Test)
		case "skip":
			skipped = append(skipped, event.Test)
		}
	}
	if err := scanner.Err(); err != nil {
		return nil, nil, err
	}
	slices.Sort(passed)
	slices.Sort(skipped)
	return passed, skipped, nil
}
