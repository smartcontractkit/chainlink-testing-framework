package seth

import (
	"crypto/ecdsa"
	"fmt"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/ethclient/simulated"
	"github.com/pelletier/go-toml/v2"
	"github.com/pkg/errors"
)

const (
	ErrReadSethConfig      = "failed to read TOML config for seth"
	ErrUnmarshalSethConfig = "failed to unmarshal TOML config for seth"
	ErrEmptyRootPrivateKey = "no root private key were set, set %s=..."

	GETH  = "Geth"
	ANVIL = "Anvil"

	CONFIG_FILE_ENV_VAR = "SETH_CONFIG_PATH"

	ROOT_PRIVATE_KEY_ENV_VAR = "SETH_ROOT_PRIVATE_KEY"
	NETWORK_ENV_VAR          = "SETH_NETWORK"
	URL_ENV_VAR              = "SETH_URL"

	DefaultNetworkName                   = "Default"
	DefaultDialTimeout                   = 1 * time.Minute
	DefaultPendingNonceProtectionTimeout = 1 * time.Minute

	DefaultTransferGasFee                  = 21_000
	DefaultGasPrice                        = 100_000_000_000 // 100 Gwei
	DefaultGasFeeCap                       = 100_000_000_000 // 100 Gwei
	DefaultGasTipCap                       = 50_000_000_000  // 50 Gwei
	DefaultGasPriceEstimationsAttemptCount = 1               // this actually means no retries, due to how the retry-go library works
)

type Config struct {
	// internal fields
	revertedTransactionsFile string
	ephemeral                bool
	RPCHeaders               http.Header
	ethclient                simulated.Client
	Hooks                    *Hooks

	// external fields
	// ArtifactDir is the directory where all artifacts generated by seth are stored (e.g. transaction traces)
	ArtifactsDir                  string            `toml:"artifacts_dir"`
	EphemeralAddrs                *int64            `toml:"ephemeral_addresses_number"`
	RootKeyFundsBuffer            *int64            `toml:"root_key_funds_buffer"`
	ABIDir                        string            `toml:"abi_dir"`
	BINDir                        string            `toml:"bin_dir"`
	GethWrappersDirs              []string          `toml:"geth_wrappers_dirs"`
	ContractMapFile               string            `toml:"contract_map_file"`
	SaveDeployedContractsMap      bool              `toml:"save_deployed_contracts_map"`
	Network                       *Network          `toml:"network"`
	Networks                      []*Network        `toml:"networks"`
	NonceManager                  *NonceManagerCfg  `toml:"nonce_manager"`
	TracingLevel                  string            `toml:"tracing_level"`
	TraceOutputs                  []string          `toml:"trace_outputs"`
	PendingNonceProtectionEnabled bool              `toml:"pending_nonce_protection_enabled"`
	PendingNonceProtectionTimeout *Duration         `toml:"pending_nonce_protection_timeout"`
	ConfigDir                     string            `toml:"abs_path"`
	ExperimentsEnabled            []string          `toml:"experiments_enabled"`
	CheckRpcHealthOnStart         bool              `toml:"check_rpc_health_on_start"`
	BlockStatsConfig              *BlockStatsConfig `toml:"block_stats"`
	GasBump                       *GasBumpConfig    `toml:"gas_bump"`
	ReadOnly                      bool              `toml:"read_only"`
	ForceHTTP                     bool              `toml:"force_http"`
}

type GasBumpConfig struct {
	Retries     uint              `toml:"retries"`
	MaxGasPrice int64             `toml:"max_gas_price"`
	StrategyFn  GasBumpStrategyFn `toml:"-"`
}

// GasBumpRetries returns the number of retries for gas bumping
func (c *Config) GasBumpRetries() uint {
	if c.GasBump == nil {
		return 0
	}

	return c.GasBump.Retries
}

// HasMaxBumpGasPrice returns true if the max gas price for gas bumping is set
func (c *Config) HasMaxBumpGasPrice() bool {
	return c.GasBump != nil && c.GasBump.MaxGasPrice > 0
}

type NonceManagerCfg struct {
	KeySyncRateLimitSec int       `toml:"key_sync_rate_limit_per_sec"`
	KeySyncTimeout      *Duration `toml:"key_sync_timeout"`
	KeySyncRetries      uint      `toml:"key_sync_retries"`
	KeySyncRetryDelay   *Duration `toml:"key_sync_retry_delay"`
}

type Network struct {
	Name                           string    `toml:"name"`
	URLs                           []string  `toml:"urls_secret"`
	ChainID                        uint64    `toml:"chain_id"`
	EIP1559DynamicFees             bool      `toml:"eip_1559_dynamic_fees"`
	GasPrice                       int64     `toml:"gas_price"`
	GasFeeCap                      int64     `toml:"gas_fee_cap"`
	GasTipCap                      int64     `toml:"gas_tip_cap"`
	GasLimit                       uint64    `toml:"gas_limit"`
	TxnTimeout                     *Duration `toml:"transaction_timeout"`
	DialTimeout                    *Duration `toml:"dial_timeout"`
	TransferGasFee                 int64     `toml:"transfer_gas_fee"`
	PrivateKeys                    []string  `toml:"private_keys_secret"`
	GasPriceEstimationEnabled      bool      `toml:"gas_price_estimation_enabled"`
	GasPriceEstimationBlocks       uint64    `toml:"gas_price_estimation_blocks"`
	GasPriceEstimationTxPriority   string    `toml:"gas_price_estimation_tx_priority"`
	GasPriceEstimationAttemptCount uint      `toml:"gas_price_estimation_attempt_count"`
}

// DefaultClient returns a Client with reasonable default config with the specified RPC URL and private keys. You should pass at least 1 private key.
// It assumes that network is EIP-1559 compatible (if it's not, the client will later automatically update its configuration to reflect it).
func DefaultClient(rpcUrl string, privateKeys []string) (*Client, error) {
	return NewClientBuilder().WithRpcUrl(rpcUrl).WithPrivateKeys(privateKeys).Build()
}

// ReadConfig reads the TOML config file from location specified by env var "SETH_CONFIG_PATH" and returns a Config struct
func ReadConfig() (*Config, error) {
	cfgPath := os.Getenv(CONFIG_FILE_ENV_VAR)
	if cfgPath == "" {
		return nil, errors.New(ErrEmptyConfigPath)
	}
	var cfg *Config
	d, err := os.ReadFile(cfgPath)
	if err != nil {
		return nil, errors.Wrap(err, ErrReadSethConfig)
	}
	err = toml.Unmarshal(d, &cfg)
	if err != nil {
		return nil, errors.Wrap(err, ErrUnmarshalSethConfig)
	}
	absPath, err := filepath.Abs(cfgPath)
	if err != nil {
		return nil, err
	}
	cfg.ConfigDir = filepath.Dir(absPath)
	selectedNetwork := os.Getenv(NETWORK_ENV_VAR)
	if selectedNetwork != "" {
		for _, n := range cfg.Networks {
			if n.Name == selectedNetwork {
				cfg.Network = n
				break
			}
		}
	}

	if cfg.Network == nil {
		L.Debug().Msgf("Network %s not found in TOML, trying to use URL", selectedNetwork)
		url := os.Getenv(URL_ENV_VAR)

		if url == "" {
			return nil, fmt.Errorf("network not selected, set %s=... or %s=..., check TOML config for available networks", NETWORK_ENV_VAR, URL_ENV_VAR)
		}

		//look for default network
		for _, n := range cfg.Networks {
			if n.Name == DefaultNetworkName {
				cfg.Network = n
				cfg.Network.Name = selectedNetwork
				cfg.Network.URLs = []string{url}

				if selectedNetwork == "" {
					L.Debug().Msg("No network name provided, using default network")
					cfg.Network.Name = DefaultNetworkName
				}

				break
			}
		}

		if cfg.Network == nil {
			return nil, fmt.Errorf("default network not defined in the TOML file")
		}
	}

	rootPrivateKey := os.Getenv(ROOT_PRIVATE_KEY_ENV_VAR)
	if rootPrivateKey == "" {
		return nil, errors.Errorf(ErrEmptyRootPrivateKey, ROOT_PRIVATE_KEY_ENV_VAR)
	}
	cfg.Network.PrivateKeys = append(cfg.Network.PrivateKeys, rootPrivateKey)
	if cfg.Network.DialTimeout == nil {
		cfg.Network.DialTimeout = &Duration{D: DefaultDialTimeout}
	}
	L.Trace().Interface("Config", cfg).Msg("Parsed seth config")
	return cfg, nil
}

// Validate checks and validates the provided Config struct.
// It ensures essential fields have valid values or default to appropriate values
// when necessary. This function performs validation on gas price estimation,
// gas limit, tracing level, trace outputs, network dial timeout, and pending nonce protection timeout.
// If any configuration is invalid, it returns an error.
func (c *Config) Validate() error {
	if c.Network == nil {
		return errors.New(ErrNetworkIsNil)
	}

	if c.Network.GasPriceEstimationEnabled {
		if c.Network.GasPriceEstimationBlocks == 0 {
			L.Debug().Msg("Gas estimation is enabled, but block headers to use is set to 0. Will not use block congestion for gas estimation")
		}
		c.Network.GasPriceEstimationTxPriority = strings.ToLower(c.Network.GasPriceEstimationTxPriority)

		if c.Network.GasPriceEstimationTxPriority == "" {
			c.Network.GasPriceEstimationTxPriority = Priority_Standard
		}

		switch c.Network.GasPriceEstimationTxPriority {
		case Priority_Degen:
		case Priority_Fast:
		case Priority_Standard:
		case Priority_Slow:
		default:
			return errors.New("when automating gas estimation is enabled priority must be fast, standard or slow. fix it or disable gas estimation")
		}

	}

	if c.Network.GasLimit != 0 {
		L.Warn().
			Msg("Gas limit is set, this will override the gas limit set by the network. This option should be used **ONLY** if node is incapable of estimating gas limit itself, which happens only with very old versions")
	}

	if c.Network.GasPriceEstimationAttemptCount == 0 {
		c.Network.GasPriceEstimationAttemptCount = DefaultGasPriceEstimationsAttemptCount
	}

	if c.TracingLevel == "" {
		c.TracingLevel = TracingLevel_Reverted
	}

	c.TracingLevel = strings.ToUpper(c.TracingLevel)

	switch c.TracingLevel {
	case TracingLevel_None:
	case TracingLevel_Reverted:
	case TracingLevel_All:
	default:
		return errors.New("tracing level must be one of: NONE, REVERTED, ALL")
	}

	for _, output := range c.TraceOutputs {
		switch strings.ToLower(output) {
		case TraceOutput_Console:
		case TraceOutput_JSON:
		case TraceOutput_DOT:
		default:
			return errors.New("trace output must be one of: console, json, dot")
		}
	}

	if c.Network.DialTimeout == nil {
		c.Network.DialTimeout = &Duration{D: DefaultDialTimeout}
	}

	if c.PendingNonceProtectionTimeout == nil {
		c.PendingNonceProtectionTimeout = &Duration{D: DefaultPendingNonceProtectionTimeout}
	}

	if c.ethclient == nil && len(c.Network.URLs) == 0 {
		return errors.New("at least one url should be present in config in 'secret_urls = []'")
	}

	if c.ethclient != nil && len(c.Network.URLs) > 0 {
		return errors.New(EthClientAndUrlsSet)
	}

	return nil
}

// MustFirstNetworkURL returns first network URL or panics if it's not set
func (c *Config) MustFirstNetworkURL() string {
	if c.Network == nil {
		panic("no Network is set in the config")
	}
	if len(c.Network.URLs) == 0 {
		panic("no URLs are set in the Network config")
	}
	return c.Network.URLs[0]
}

// ParseKeys parses private keys from the config
func (c *Config) ParseKeys() ([]common.Address, []*ecdsa.PrivateKey, error) {
	addresses := make([]common.Address, 0)
	privKeys := make([]*ecdsa.PrivateKey, 0)
	for _, k := range c.Network.PrivateKeys {
		privateKey, err := crypto.HexToECDSA(k)
		if err != nil {
			return nil, nil, err
		}
		publicKey := privateKey.Public()
		publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)
		if !ok {
			return nil, nil, err
		}
		pubKeyAddress := crypto.PubkeyToAddress(*publicKeyECDSA)
		addresses = append(addresses, pubKeyAddress)
		privKeys = append(privKeys, privateKey)
	}
	return addresses, privKeys, nil
}

// IsSimulatedNetwork returns true if the network is simulated (i.e. Geth or Anvil)
func (c *Config) IsSimulatedNetwork() bool {
	networkName := strings.ToLower(c.Network.Name)
	return networkName == strings.ToLower(GETH) || networkName == strings.ToLower(ANVIL)
}

// GenerateContractMapFileName generates a file name for the contract map
func (c *Config) GenerateContractMapFileName() string {
	networkName := strings.ToLower(c.Network.Name)
	now := time.Now().Format("2006-01-02-15-04-05")
	return fmt.Sprintf(ContractMapFilePattern, networkName, now)
}

// ShouldSaveDeployedContractMap returns true if the contract map should be saved (i.e. not a simulated network and functionality is enabled)
func (c *Config) ShouldSaveDeployedContractMap() bool {
	return !c.IsSimulatedNetwork() && c.SaveDeployedContractsMap
}

func (c *Config) setEphemeralAddrs() {
	if c.EphemeralAddrs == nil {
		c.EphemeralAddrs = &ZeroInt64
	}

	if *c.EphemeralAddrs == 0 {
		c.ephemeral = false
	} else {
		c.ephemeral = true
	}

	if c.RootKeyFundsBuffer == nil {
		c.RootKeyFundsBuffer = &ZeroInt64
	}
}

const (
	Experiment_SlowFundsReturn    = "slow_funds_return"
	Experiment_Eip1559FeeEqualier = "eip_1559_fee_equalizer"
)

// IsExperimentEnabled returns true if the experiment is enabled
func (c *Config) IsExperimentEnabled(experiment string) bool {
	for _, e := range c.ExperimentsEnabled {
		if e == experiment {
			return true
		}
	}
	return false
}

// AppendPksToNetwork appends private keys to the network with the specified name and returns "true" if the network was updated.
func (c *Config) AppendPksToNetwork(pks []string, name string) bool {
	if c.Network != nil && strings.EqualFold(c.Network.Name, name) {
		c.Network.PrivateKeys = append(c.Network.PrivateKeys, pks...)

		return true
	}

	for _, n := range c.Networks {
		if strings.EqualFold(n.Name, name) {
			n.PrivateKeys = append(c.Network.PrivateKeys, pks...)
			return true
		}
	}

	return false
}

// GetMaxConcurrency returns the maximum number of concurrent transactions. Root key is excluded from the count.
func (c *Config) GetMaxConcurrency() int {
	if c.ephemeral {
		return int(*c.EphemeralAddrs)
	}

	return len(c.Network.PrivateKeys) - 1
}

func (c *Config) hasOutput(output string) bool {
	for _, o := range c.TraceOutputs {
		if strings.EqualFold(o, output) {
			return true
		}
	}

	return false
}

func (c *Config) findNetworkByName(name string) *Network {
	for _, n := range c.Networks {
		if strings.EqualFold(n.Name, name) {
			return n
		}
	}

	return nil
}
