# WASP - Testing Alerts

Okay, you have your load profile set up and running. Now, let's see how you can monitor and assert on the metrics generated by the generated load.

For that will need to use a Grafana dashboard. We will generate it and alerts programmatically, but if you already
have a dashboard with alerts you can also use them to make assertions with WASP.

> [!NOTE]
> Read more about asserting on Alerts for existing dashboard in the [AlertChecker](./components/alert_checker.md) component description.

We will use a simple HTTP `Gun` that was used in previous examples, so we will skip its definition here for brevity.
For the sake of this example, we will divide alerts into two groups:
* baseline
* stress

Let's start with some constants that will be useful later on:
```go
const (
    FirstGenName                 = "first API"
    SecondGenName                = "second API"
    BaselineRequirementGroupName = "baseline"
    StressRequirementGroupName   = "stress"
)
```

Now, let's define an alert that will trigger when the 99th percentile of the response time is greater than 50ms.

```go
fiftyMsAlert := dashboard.WaspAlert{
    Name:                 "99th latency percentile is out of SLO for first API",
    AlertType:            dashboard.AlertTypeQuantile99,
    TestName:             "TestBaselineRequirements",
    GenName:              FirstGenName,
    RequirementGroupName: BaselineRequirementGroupName,
    AlertIf:              alert.IsAbove(50),
}
```

> [!NOTE]
> You can read more about various alert types supported by WASP in the [AlertChecker](./components/alert_checker.md) component description.

For the second API, let's define an alert that will fire if there were any errors, when calling the second generator:
```go
anyErrorsAlert := dashboard.WaspAlert{	
    Name:                 "second API has errors",
    AlertType:            dashboard.AlertTypeErrors,
    TestName:             "TestBaselineRequirements",
    GenName:              SecondGenName,
    RequirementGroupName: BaselineRequirementGroupName,
    AlertIf:              alert.IsAbove(0),
}
```

And finally, a more complex alert for the `stress` group of alerts:
```go
customAlert := dashboard.WaspAlert{
    RequirementGroupName: StressRequirementGroupName,
    Name:                 "MyCustomALert",
    CustomAlert: timeseries.Alert(
        "MyCustomAlert", 
        alert.For("10s"),                             // let it alert for 10s, before considering it as a firing alert
        alert.OnExecutionError(alert.ErrorAlerting),  // modify "alerting state" to "alerting" if there is an error, so we don't miss it
        alert.Description("My custom description"),
        alert.Tags(map[string]string{
            "service": "wasp",
            // set group label so it can be filtered
            dashboard.DefaultRequirementLabelKey: StressRequirementGroupName,
        }),
        alert.WithLokiQuery(
            "MyCustomAlert",
            `
max_over_time({go_test_name="%s", test_data_type=~"stats", gen_name="%s"}
| json
| unwrap failed [10s]) by (go_test_name, gen_name)`,
        ),
        alert.If(alert.Last, "MyCustomAlert", alert.IsAbove(20)), // alert, if at least 20 matches were found
        alert.EvaluateEvery("10s"),                               // in the last 10s
    ),
},
```

The Loki query filters logs by `go_test_name` and `gen_name` labels (added automatically by WASP), then parses them for JSON-formatted fields. Specifically, it monitors a `failed` field within the JSON logs and calculates the maximum count over the last 10 seconds for each combination of `go_test_name` and `gen_name`.
The alert will trigger if there are at least 20 failed logs in the last 10 seconds.

Now, let's build a default WASP dashboard with these alerts, and deploy it to Grafana:
```go
func buildDashboard() (*dashboard.Dashboard, error) {
    // build the dashboard
    d, err := dashboard.NewDashboard([]dashboard.WaspAlert{
        fiftyMsAlert,
        anyErrorsAlert,
        customAlert,
    })
    
    if err != nil {
        return nil, err
    }
    
    // create in Grafana
    return d.Deploy()
}
```

With dashboard deployed, `Gun` already defined, we can create the test:
```go
func TestBaselineRequirements(t *testing.T) {
    // start HTTP mock server
    srv := wasp.NewHTTPMockServer(
        &wasp.HTTPMockServerConfig{
            FirstAPILatency:   50 * time.Millisecond,
			FirstAPIHTTPCode:  500,
            SecondAPILatency:  50 * time.Millisecond,
            SecondAPIHTTPCode: 500})
    
	srv.Run()
	
	// build and deploy dashboard
    dashboard, err := buildDashboard()
	require.NoError(t, err)
	
	// define a profile with 2 load generators
    _, err := wasp.NewProfile().
        Add(wasp.NewGenerator(&wasp.Config{
            T:          t,
            LoadType:   wasp.RPS,
            GenName:    FirstGenName,
            Schedule:   wasp.Plain(5, 20*time.Second),
            Gun:        NewExampleHTTPGun(srv.URL()),
            LokiConfig: wasp.NewEnvLokiConfig(),
        })).
        Add(wasp.NewGenerator(&wasp.Config{
            T:          t,
            LoadType:   wasp.RPS,
            GenName:    SecondGenName,
            Schedule:   wasp.Plain(5, 20*time.Second),
            Gun:        NewExampleHTTPGun(srv.URL()),
            LokiConfig: wasp.NewEnvLokiConfig(),
        })).
        Run(true)
    
    require.NoError(t, err)

	// we are checking all active alerts for dashboard with UUID = "wasp" which have label "requirement_name" = "baseline"
	// if any alerts of particular group, for example "baseline" were raised - we fail the test
	// change some data in NewHTTPMockServer to make alerts disappear
	_, err = wasp.NewAlertChecker(t).AnyAlerts(dashboard.DefaultDashboardUUID, BaselineRequirementGroupName)
	require.NoError(t, err)
	
	// now let's check the "stress" alerts group
    _, err = wasp.NewAlertChecker(t).AnyAlerts(dashboard.DefaultDashboardUUID, StressRequirementGroupName)
    require.NoError(t, err)
}
```

> [!WARNING]
> This example assumes that you have a Grafana instance setup. If you don't, please set it up, before executing the test.
> You can find more information on how to set up Grafana locally [here](./local_loki_grafana_stack.md).
> 
> WASP will try to read Grafana configuration from the environment variables. More about them in the [Configuration](./configuration.md) section.

This test will start two load generators, each simulating a different API. It will then assert that the alerts defined in the `baseline` group are not triggered. If any of them are, the test will fail.

Now you know everything you need to know to start writing loads tests and making assertions on the application behaviour!

You can find the full example that defines more alerts and assertions in the [here](https://github.com/smartcontractkit/chainlink-testing-framework/tree/main/wasp/examples/alerts)