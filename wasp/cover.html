
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>benchspy: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/smartcontractkit/chainlink-testing-framework/wasp/benchspy/basic.go (93.1%)</option>
				
				<option value="file1">github.com/smartcontractkit/chainlink-testing-framework/wasp/benchspy/direct.go (90.1%)</option>
				
				<option value="file2">github.com/smartcontractkit/chainlink-testing-framework/wasp/benchspy/log.go (87.5%)</option>
				
				<option value="file3">github.com/smartcontractkit/chainlink-testing-framework/wasp/benchspy/loki.go (89.5%)</option>
				
				<option value="file4">github.com/smartcontractkit/chainlink-testing-framework/wasp/benchspy/metrics.go (100.0%)</option>
				
				<option value="file5">github.com/smartcontractkit/chainlink-testing-framework/wasp/benchspy/prometheus.go (79.3%)</option>
				
				<option value="file6">github.com/smartcontractkit/chainlink-testing-framework/wasp/benchspy/report.go (89.0%)</option>
				
				<option value="file7">github.com/smartcontractkit/chainlink-testing-framework/wasp/benchspy/storage.go (94.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package benchspy

import (
        "encoding/json"
        "fmt"
        "time"

        "github.com/pkg/errors"
        "github.com/smartcontractkit/chainlink-testing-framework/wasp"
)

// BasicData is the basic data that is required for a report, common to all reports
type BasicData struct {
        TestName    string `json:"test_name"`
        CommitOrTag string `json:"commit_or_tag"`

        // Test metrics
        TestStart time.Time `json:"test_start_timestamp"`
        TestEnd   time.Time `json:"test_end_timestamp"`

        // all, generator settings, including segments
        GeneratorConfigs map[string]*wasp.Config `json:"generator_configs"`
}

// MustNewBasicData creates a new BasicData instance from a commit or tag.
// It panics if the creation fails, ensuring that the caller receives a valid instance.
func MustNewBasicData(commitOrTag string, generators ...*wasp.Generator) BasicData <span class="cov2" title="2">{
        b, err := NewBasicData(commitOrTag, generators...)
        if err != nil </span><span class="cov1" title="1">{
                panic(err)</span>
        }

        <span class="cov1" title="1">return *b</span>
}

// NewBasicData creates a new BasicData instance using the provided commit or tag and a list of generators.
// It ensures that at least one generator is provided and that it is associated with a testing.T instance. 
// This function is essential for initializing test data configurations in a structured manner.
func NewBasicData(commitOrTag string, generators ...*wasp.Generator) (*BasicData, error) <span class="cov9" title="31">{
        if len(generators) == 0 </span><span class="cov3" title="3">{
                return nil, errors.New("at least one generator is required")
        }</span>

        <span class="cov9" title="28">if generators[0].Cfg.T == nil </span><span class="cov1" title="1">{
                return nil, errors.New("generators are not associated with a testing.T instance. Please set it as generator.Cfg.T and try again")
        }</span>

        <span class="cov9" title="27">b := &amp;BasicData{
                TestName:         generators[0].Cfg.T.Name(),
                CommitOrTag:      commitOrTag,
                GeneratorConfigs: make(map[string]*wasp.Config),
        }

        for _, g := range generators </span><span class="cov9" title="28">{
                b.GeneratorConfigs[g.Cfg.GenName] = g.Cfg
        }</span>

        <span class="cov9" title="27">timeErr := b.FillStartEndTimes()
        if timeErr != nil </span><span class="cov3" title="3">{
                return nil, timeErr
        }</span>

        <span class="cov9" title="24">return b, nil</span>
}

// FillStartEndTimes calculates the earliest start time and latest end time from generator schedules.
// It updates the BasicData instance with these times, ensuring all segments have valid start and end times.
func (b *BasicData) FillStartEndTimes() error <span class="cov9" title="30">{
        earliestTime := time.Now()
        var latestTime time.Time

        for _, cfg := range b.GeneratorConfigs </span><span class="cov9" title="32">{
                if len(cfg.Schedule) == 0 </span><span class="cov1" title="1">{
                        return fmt.Errorf("schedule is empty for generator %s", cfg.GenName)
                }</span>

                <span class="cov9" title="31">for _, segment := range cfg.Schedule </span><span class="cov10" title="35">{
                        if segment.StartTime.IsZero() </span><span class="cov1" title="1">{
                                return fmt.Errorf("start time is missing in one of the segments belonging to generator %s. Did that generator run?", cfg.GenName)
                        }</span>
                        <span class="cov9" title="34">if segment.StartTime.Before(earliestTime) </span><span class="cov9" title="29">{
                                earliestTime = segment.StartTime
                        }</span>
                        <span class="cov9" title="34">if segment.EndTime.IsZero() </span><span class="cov1" title="1">{
                                return fmt.Errorf("end time is missing in one of the segments belonging to generator %s. Did that generator finish running?", cfg.GenName)
                        }</span>
                        <span class="cov9" title="33">if segment.EndTime.After(latestTime) </span><span class="cov9" title="31">{
                                latestTime = segment.EndTime
                        }</span>
                }
        }

        <span class="cov9" title="27">b.TestStart = earliestTime
        b.TestEnd = latestTime

        return nil</span>
}

// Validate checks the integrity of the BasicData fields, ensuring that the test start and end times are set,
// and that at least one generator configuration is provided. It returns an error if any of these conditions are not met.
func (b *BasicData) Validate() error <span class="cov8" title="20">{
        if b.TestStart.IsZero() </span><span class="cov1" title="1">{
                return errors.New("test start time is missing. We cannot query Loki without a time range. Please set it and try again")
        }</span>
        <span class="cov8" title="19">if b.TestEnd.IsZero() </span><span class="cov0" title="0">{
                return errors.New("test end time is missing. We cannot query Loki without a time range. Please set it and try again")
        }</span>

        <span class="cov8" title="19">if len(b.GeneratorConfigs) == 0 </span><span class="cov1" title="1">{
                return errors.New("generator configs are missing. At least one is required. Please set them and try again")
        }</span>

        <span class="cov8" title="18">return nil</span>
}

// IsComparable checks if two BasicData instances have the same configuration settings.
// It validates the count, presence, and equivalence of generator configurations,
// returning an error if any discrepancies are found. This function is useful for ensuring
// consistency between data reports before processing or comparison.
func (b *BasicData) IsComparable(otherData BasicData) error <span class="cov5" title="7">{
        // are all configs present? do they have the same schedule type? do they have the same segments? is call timeout the same? is rate limit timeout the same?
        if len(b.GeneratorConfigs) != len(otherData.GeneratorConfigs) </span><span class="cov1" title="1">{
                return fmt.Errorf("generator configs count is different. Expected %d, got %d", len(b.GeneratorConfigs), len(otherData.GeneratorConfigs))
        }</span>

        <span class="cov5" title="6">for name1, cfg1 := range b.GeneratorConfigs </span><span class="cov5" title="6">{
                if cfg2, ok := otherData.GeneratorConfigs[name1]; !ok </span><span class="cov3" title="3">{
                        return fmt.Errorf("generator config %s is missing from the other report", name1)
                }</span> else<span class="cov3" title="3"> {
                        if err := compareGeneratorConfigs(cfg1, cfg2); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov3" title="3">return nil</span>
}

func compareGeneratorConfigs(cfg1, cfg2 *wasp.Config) error <span class="cov8" title="17">{
        if cfg1.GenName != cfg2.GenName </span><span class="cov1" title="1">{
                return fmt.Errorf("generator names are different. Expected %s, got %s", cfg1.GenName, cfg2.GenName)
        }</span>
        <span class="cov8" title="16">if cfg1.LoadType != cfg2.LoadType </span><span class="cov1" title="1">{
                return fmt.Errorf("load types are different. Expected %s, got %s", cfg1.LoadType, cfg2.LoadType)
        }</span>

        <span class="cov7" title="15">if len(cfg1.Schedule) != len(cfg2.Schedule) </span><span class="cov1" title="1">{
                return fmt.Errorf("schedules are different. Expected %d, got %d", len(cfg1.Schedule), len(cfg2.Schedule))
        }</span>

        <span class="cov7" title="14">var areSegmentsEqual = func(segment1, segment2 *wasp.Segment) bool </span><span class="cov7" title="14">{
                return segment1.From == segment2.From &amp;&amp; segment1.Duration == segment2.Duration &amp;&amp; segment1.Type == segment2.Type
        }</span>

        <span class="cov7" title="14">for i, segment1 := range cfg1.Schedule </span><span class="cov7" title="14">{
                segment2 := cfg2.Schedule[i]
                if segment1 == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("segment at index %d is nil in the current report", i)
                }</span>
                <span class="cov7" title="14">if segment2 == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("segment at index %d is nil in the other report", i)
                }</span>
                <span class="cov7" title="14">if !areSegmentsEqual(segment1, segment2) </span><span class="cov4" title="4">{
                        return fmt.Errorf("segments at index %d are different. Expected %s segment(s), got %s segment(s)", i, mustMarshallSegment(segment1), mustMarshallSegment(segment2))
                }</span>
        }

        <span class="cov6" title="10">if cfg1.CallTimeout != cfg2.CallTimeout </span><span class="cov1" title="1">{
                return fmt.Errorf("call timeouts are different. Expected %s, got %s", cfg1.CallTimeout, cfg2.CallTimeout)
        }</span>

        <span class="cov6" title="9">if cfg1.RateLimitUnitDuration != cfg2.RateLimitUnitDuration </span><span class="cov1" title="1">{
                return fmt.Errorf("rate limit unit durations are different. Expected %s, got %s", cfg1.RateLimitUnitDuration, cfg2.RateLimitUnitDuration)
        }</span>

        <span class="cov6" title="8">return nil</span>
}

func mustMarshallSegment(segment *wasp.Segment) string <span class="cov6" title="9">{
        segmentBytes, err := json.MarshalIndent(segment, "", " ")
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov6" title="9">return string(segmentBytes)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package benchspy

import (
        "context"
        "encoding/json"
        "fmt"
        "reflect"
        "time"

        "github.com/montanaflynn/stats"
        "github.com/pkg/errors"
        "github.com/smartcontractkit/chainlink-testing-framework/wasp"
)

type DirectQueryFn = func(responses *wasp.SliceBuffer[wasp.Response]) (float64, error)

type DirectQueryExecutor struct {
        KindName     string                   `json:"kind"`
        Generator    *wasp.Generator          `json:"generator_config"`
        Queries      map[string]DirectQueryFn `json:"queries"`
        QueryResults map[string]interface{}   `json:"query_results"`
}

// NewStandardDirectQueryExecutor creates a new DirectQueryExecutor configured for standard queries.
// It initializes the executor and generates the necessary queries, returning the executor or an error if the process fails.
func NewStandardDirectQueryExecutor(generator *wasp.Generator) (*DirectQueryExecutor, error) <span class="cov7" title="20">{
        g := &amp;DirectQueryExecutor{
                KindName: string(StandardQueryExecutor_Direct),
        }

        queries, err := g.generateStandardQueries()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov7" title="20">return NewDirectQueryExecutor(generator, queries)</span>
}

// NewDirectQueryExecutor creates a new DirectQueryExecutor with the specified generator and query functions.
// It initializes the executor with a kind name and prepares a map for query results, enabling efficient query execution.
func NewDirectQueryExecutor(generator *wasp.Generator, queries map[string]DirectQueryFn) (*DirectQueryExecutor, error) <span class="cov7" title="20">{
        g := &amp;DirectQueryExecutor{
                KindName:     string(StandardQueryExecutor_Direct),
                Generator:    generator,
                Queries:      queries,
                QueryResults: make(map[string]interface{}),
        }

        return g, nil
}</span>

// Results returns the query results as a map of string keys to interface{} values.
// It allows users to access the outcomes of executed queries, facilitating further processing or type assertions.
func (g *DirectQueryExecutor) Results() map[string]interface{} <span class="cov5" title="9">{
        return g.QueryResults
}</span>

// Kind returns the type of the query executor as a string.
// It is useful for identifying the specific implementation of a query executor in a collection.
func (l *DirectQueryExecutor) Kind() string <span class="cov2" title="2">{
        return l.KindName
}</span>

// IsComparable checks if the given QueryExecutor is of the same type and has comparable configurations.
// It returns an error if the types do not match or if the configurations are not comparable.
func (g *DirectQueryExecutor) IsComparable(otherQueryExecutor QueryExecutor) error <span class="cov4" title="6">{
        otherType := reflect.TypeOf(otherQueryExecutor)

        if otherType != reflect.TypeOf(g) </span><span class="cov1" title="1">{
                return fmt.Errorf("expected type %s, got %s", reflect.TypeOf(g), otherType)
        }</span>

        <span class="cov4" title="5">otherGeneratorQueryExecutor := otherQueryExecutor.(*DirectQueryExecutor)

        if compareGeneratorConfigs(g.Generator.Cfg, otherGeneratorQueryExecutor.Generator.Cfg) != nil </span><span class="cov1" title="1">{
                return errors.New("generators are not comparable")
        }</span>

        <span class="cov3" title="4">return g.compareQueries(otherGeneratorQueryExecutor.Queries)</span>
}

func (l *DirectQueryExecutor) compareQueries(other map[string]DirectQueryFn) error <span class="cov3" title="4">{
        this := l.Queries
        if len(this) != len(other) </span><span class="cov2" title="2">{
                return fmt.Errorf("queries count is different. Expected %d, got %d", len(this), len(other))
        }</span>

        <span class="cov2" title="2">for name1 := range this </span><span class="cov5" title="8">{
                if _, ok := other[name1]; !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("query %s is missing from the other report", name1)
                }</span>
        }

        <span class="cov2" title="2">return nil</span>
}

// Validate checks if the query executor is properly configured.
// It ensures that a generator is set and at least one query is provided.
// Returns an error if validation fails, helping to prevent execution issues.
func (g *DirectQueryExecutor) Validate() error <span class="cov5" title="10">{
        if g.Generator == nil </span><span class="cov2" title="2">{
                return errors.New("generator is not set")
        }</span>

        <span class="cov5" title="8">if len(g.Queries) == 0 </span><span class="cov1" title="1">{
                return errors.New("at least one query is needed")
        }</span>

        <span class="cov4" title="7">return nil</span>
}

// Execute runs the defined queries using the data from the generator.
// It validates the generator's data and aggregates responses before executing each query.
// This function is essential for processing and retrieving results from multiple queries concurrently.
func (g *DirectQueryExecutor) Execute(_ context.Context) error <span class="cov3" title="4">{
        if g.Generator == nil </span><span class="cov0" title="0">{
                return errors.New("generator is not set")
        }</span>

        <span class="cov3" title="4">for queryName, queryFunction := range g.Queries </span><span class="cov6" title="13">{
                if g.Generator.GetData() == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("generator %s has no data", g.Generator.Cfg.GenName)
                }</span>
                <span class="cov6" title="13">length := len(g.Generator.GetData().FailResponses.Data) + len(g.Generator.GetData().OKData.Data)
                allResponses := wasp.NewSliceBuffer[wasp.Response](length)

                for _, response := range g.Generator.GetData().OKResponses.Data </span><span class="cov7" title="28">{
                        allResponses.Append(*response)
                }</span>

                <span class="cov6" title="13">for _, response := range g.Generator.GetData().FailResponses.Data </span><span class="cov8" title="32">{
                        allResponses.Append(*response)
                }</span>

                <span class="cov6" title="13">if len(allResponses.Data) == 0 </span><span class="cov1" title="1">{
                        return fmt.Errorf("no responses found for generator %s", g.Generator.Cfg.GenName)
                }</span>

                <span class="cov6" title="12">results, queryErr := queryFunction(allResponses)
                if queryErr != nil </span><span class="cov0" title="0">{
                        return queryErr
                }</span>

                <span class="cov6" title="12">g.QueryResults[queryName] = results</span>
        }

        <span class="cov3" title="3">return nil</span>
}

// TimeRange ensures that the query executor operates within the specified time range.
// It is a no-op for executors that already have responses stored in the correct time range.
func (g *DirectQueryExecutor) TimeRange(_, _ time.Time) {<span class="cov3" title="3">
        // nothing to do here, since all responses stored in the generator are already in the right time range
}</span>

func (g *DirectQueryExecutor) generateStandardQueries() (map[string]DirectQueryFn, error) <span class="cov7" title="20">{
        standardQueries := make(map[string]DirectQueryFn)

        for _, metric := range StandardLoadMetrics </span><span class="cov10" title="80">{
                query, err := g.standardQuery(metric)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov10" title="80">standardQueries[string(metric)] = query</span>
        }

        <span class="cov7" title="20">return standardQueries, nil</span>
}

func (g *DirectQueryExecutor) standardQuery(standardMetric StandardLoadMetric) (DirectQueryFn, error) <span class="cov10" title="80">{
        switch standardMetric </span>{
        case MedianLatency:<span class="cov7" title="20">
                medianFn := func(responses *wasp.SliceBuffer[wasp.Response]) (float64, error) </span><span class="cov3" title="3">{
                        var asMiliDuration []float64
                        for _, response := range responses.Data </span><span class="cov6" title="15">{
                                // get duration as nanoseconds and convert to milliseconds in order to not lose precision
                                // otherwise, the duration will be rounded to the nearest millisecond
                                asMiliDuration = append(asMiliDuration, float64(response.Duration.Nanoseconds())/1_000_000)
                        }</span>

                        <span class="cov3" title="3">return stats.Median(asMiliDuration)</span>
                }
                <span class="cov7" title="20">return medianFn, nil</span>
        case Percentile95Latency:<span class="cov7" title="20">
                p95Fn := func(responses *wasp.SliceBuffer[wasp.Response]) (float64, error) </span><span class="cov3" title="3">{
                        var asMiliDuration []float64
                        for _, response := range responses.Data </span><span class="cov6" title="15">{
                                // get duration as nanoseconds and convert to milliseconds in order to not lose precision
                                // otherwise, the duration will be rounded to the nearest millisecond
                                asMiliDuration = append(asMiliDuration, float64(response.Duration.Nanoseconds())/1_000_000)
                        }</span>

                        <span class="cov3" title="3">return stats.Percentile(asMiliDuration, 95)</span>
                }
                <span class="cov7" title="20">return p95Fn, nil</span>
        case MaxLatency:<span class="cov7" title="20">
                maxFn := func(responses *wasp.SliceBuffer[wasp.Response]) (float64, error) </span><span class="cov3" title="3">{
                        var asMiliDuration []float64
                        for _, response := range responses.Data </span><span class="cov6" title="15">{
                                // get duration as nanoseconds and convert to milliseconds in order to not lose precision
                                // otherwise, the duration will be rounded to the nearest millisecond
                                asMiliDuration = append(asMiliDuration, float64(response.Duration.Nanoseconds())/1_000_000)
                        }</span>

                        <span class="cov3" title="3">return stats.Max(asMiliDuration)</span>
                }
                <span class="cov7" title="20">return maxFn, nil</span>
        case ErrorRate:<span class="cov7" title="20">
                errorRateFn := func(responses *wasp.SliceBuffer[wasp.Response]) (float64, error) </span><span class="cov3" title="3">{
                        if len(responses.Data) == 0 </span><span class="cov0" title="0">{
                                return 0, nil
                        }</span>

                        <span class="cov3" title="3">failedCount := 0.0
                        successfulCount := 0.0
                        for _, response := range responses.Data </span><span class="cov6" title="15">{
                                if response.Failed || response.Timeout </span><span class="cov5" title="8">{
                                        failedCount = failedCount + 1
                                }</span> else<span class="cov4" title="7"> {
                                        successfulCount = successfulCount + 1
                                }</span>
                        }

                        <span class="cov3" title="3">return failedCount / (failedCount + successfulCount), nil</span>
                }
                <span class="cov7" title="20">return errorRateFn, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported standard metric %s", standardMetric)</span>
        }
}

// MarshalJSON customizes the JSON representation of the DirectQueryExecutor.
// It serializes only the relevant fields, including query names and results,
// making it suitable for efficient data transmission and storage.
func (g *DirectQueryExecutor) MarshalJSON() ([]byte, error) <span class="cov3" title="3">{
        // we need custom marshalling to only include query names, since the functions are not serializable
        type QueryExecutor struct {
                Kind         string                 `json:"kind"`
                Generator    interface{}            `json:"generator_config"`
                Queries      []string               `json:"queries"`
                QueryResults map[string]interface{} `json:"query_results"`
        }

        return json.Marshal(&amp;QueryExecutor{
                Kind: g.KindName,
                Generator: func() interface{} </span><span class="cov3" title="3">{
                        if g.Generator != nil </span><span class="cov2" title="2">{
                                return g.Generator.Cfg
                        }</span>
                        <span class="cov1" title="1">return nil</span>
                }(),
                Queries: func() []string <span class="cov3" title="3">{
                        keys := make([]string, 0, len(g.Queries))
                        for k := range g.Queries </span><span class="cov4" title="6">{
                                keys = append(keys, k)
                        }</span>
                        <span class="cov3" title="3">return keys</span>
                }(),
                QueryResults: g.QueryResults,
        })
}

// UnmarshalJSON decodes JSON data into a DirectQueryExecutor instance.
// It populates the executor's fields, including queries and results,
// enabling seamless integration of JSON configurations into the executor's structure.
func (g *DirectQueryExecutor) UnmarshalJSON(data []byte) error <span class="cov3" title="3">{
        // helper struct with QueryExecutors as json.RawMessage and QueryResults as map[string]interface{}
        // and as actual types
        type Alias DirectQueryExecutor
        var raw struct {
                Alias
                GeneratorCfg wasp.Config            `json:"generator_config"`
                Queries      []json.RawMessage      `json:"queries"`
                QueryResults map[string]interface{} `json:"query_results"`
        }

        // unmarshal into the helper struct to populate other fields automatically
        if err := json.Unmarshal(data, &amp;raw); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov3" title="3">queries := make(map[string]DirectQueryFn)

        // unmarshall only query names
        for _, rawQuery := range raw.Queries </span><span class="cov4" title="7">{
                var queryName string
                if err := json.Unmarshal(rawQuery, &amp;queryName); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov4" title="7">queries[queryName] = nil</span>
        }

        // convert map[string]interface{} to map[string]actualType
        <span class="cov3" title="3">convertedTypes, conversionErr := convertQueryResults(raw.QueryResults)
        if conversionErr != nil </span><span class="cov0" title="0">{
                return conversionErr
        }</span>

        <span class="cov3" title="3">*g = DirectQueryExecutor(raw.Alias)
        g.Queries = queries
        g.QueryResults = convertedTypes
        g.Generator = &amp;wasp.Generator{
                Cfg: &amp;raw.GeneratorCfg,
        }
        return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package benchspy

import (
        "os"

        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
)

const (
        LogLevelEnvVar = "BENCHSPY_LOG_LEVEL"
)

var (
        L zerolog.Logger
)

func init() <span class="cov8" title="1">{
        initDefaultLogging()
}</span>

func initDefaultLogging() <span class="cov8" title="1">{
        lvlStr := os.Getenv(LogLevelEnvVar)
        if lvlStr == "" </span><span class="cov8" title="1">{
                lvlStr = "info"
        }</span>
        <span class="cov8" title="1">lvl, err := zerolog.ParseLevel(lvlStr)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">L = log.Output(zerolog.ConsoleWriter{Out: os.Stderr}).Level(lvl)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package benchspy

import (
        "context"
        "encoding/json"
        "fmt"
        "net/url"
        "reflect"
        "strings"
        "time"

        "github.com/pkg/errors"
        "github.com/smartcontractkit/chainlink-testing-framework/lib/client"
        "github.com/smartcontractkit/chainlink-testing-framework/wasp"
        "golang.org/x/sync/errgroup"
)

var (
        Loki_MedianQuery = `quantile_over_time(0.5, {branch=~"%s", commit=~"%s", go_test_name=~"%s", test_data_type=~"responses", gen_name=~"%s"} | json| unwrap duration [%s]) by (go_test_name, gen_name) / 1e6`
        Loki_95thQuery   = `quantile_over_time(0.95, {branch=~"%s", commit=~"%s", go_test_name=~"%s", test_data_type=~"responses", gen_name=~"%s"} | json| unwrap duration [%s]) by (go_test_name, gen_name) / 1e6`
        Loki_MaxQuery    = `max(max_over_time({branch=~"%s", commit=~"%s", go_test_name=~"%s", test_data_type=~"responses", gen_name=~"%s"} | json| unwrap duration [%s]) by (go_test_name, gen_name) / 1e6)`
        Loki_ErrorRate   = `sum(max_over_time({branch=~"%s", commit=~"%s", go_test_name=~"%s", test_data_type=~"stats", gen_name=~"%s"} | json| unwrap failed [%s]) by (node_id, go_test_name, gen_name)) by (__stream_shard__)`
)

// NewLokiQueryExecutor creates a new LokiQueryExecutor instance.
// It initializes the executor with provided queries and Loki configuration,
// enabling efficient querying of logs from Loki in a structured manner.
func NewLokiQueryExecutor(queries map[string]string, lokiConfig *wasp.LokiConfig) *LokiQueryExecutor <span class="cov1" title="1">{
        return &amp;LokiQueryExecutor{
                KindName:     string(StandardQueryExecutor_Loki),
                Queries:      queries,
                Config:       lokiConfig,
                QueryResults: make(map[string]interface{}),
        }
}</span>

type LokiQueryExecutor struct {
        KindName string `json:"kind"`
        // Test metrics
        StartTime time.Time `json:"start_time"`
        EndTime   time.Time `json:"end_time"`

        // Performance queries
        // a map of name to query template, ex: "average cpu usage": "avg(rate(cpu_usage_seconds_total[5m]))"
        Queries map[string]string `json:"queries"`
        // Performance queries results
        // can be anything, avg RPS, amount of errors, 95th percentile of CPU utilization, etc
        QueryResults map[string]interface{} `json:"query_results"`

        Config *wasp.LokiConfig `json:"-"`
}

// Results returns the query results as a map of string to interface{}.
// It allows users to access the outcomes of executed queries, facilitating further processing or type assertions.
func (l *LokiQueryExecutor) Results() map[string]interface{} <span class="cov3" title="4">{
        return l.QueryResults
}</span>

// Kind returns the type of the query executor as a string.
// It is used to identify the specific kind of query executor in various operations.
func (l *LokiQueryExecutor) Kind() string <span class="cov1" title="1">{
        return l.KindName
}</span>

// IsComparable checks if the given QueryExecutor is of the same type as the current instance.
// It compares the queries of both executors to ensure they are equivalent in structure and content.
// This function is useful for validating compatibility between different query executors.
func (l *LokiQueryExecutor) IsComparable(otherQueryExecutor QueryExecutor) error <span class="cov4" title="7">{
        otherType := reflect.TypeOf(otherQueryExecutor)

        if otherType != reflect.TypeOf(l) </span><span class="cov1" title="1">{
                return fmt.Errorf("expected type %s, got %s", reflect.TypeOf(l), otherType)
        }</span>

        <span class="cov4" title="6">return l.compareQueries(otherQueryExecutor.(*LokiQueryExecutor).Queries)</span>
}

// Validate checks if the LokiQueryExecutor has valid queries and configuration.
// It returns an error if no queries are set or if the configuration is missing,
// ensuring that the executor is ready for execution.
func (l *LokiQueryExecutor) Validate() error <span class="cov6" title="13">{
        if len(l.Queries) == 0 </span><span class="cov1" title="1">{
                return errors.New("there are no Loki queries, there's nothing to fetch. Please set them and try again")
        }</span>
        <span class="cov5" title="12">if l.Config == nil </span><span class="cov2" title="2">{
                return errors.New("loki config is missing. Please set it and try again")
        }</span>

        <span class="cov5" title="10">return nil</span>
}

// Execute runs the configured Loki queries concurrently and collects the results.
// It requires a valid configuration and handles basic authentication if provided.
// The function returns an error if any query execution fails or if the configuration is missing.
func (l *LokiQueryExecutor) Execute(ctx context.Context) error <span class="cov1" title="1">{
        var basicAuth client.LokiBasicAuth

        if l.Config == nil </span><span class="cov0" title="0">{
                return errors.New("loki config is missing. Please set it and try again")
        }</span>

        <span class="cov1" title="1">if l.Config.BasicAuth != "" </span><span class="cov1" title="1">{
                splitAuth := strings.Split(l.Config.BasicAuth, ":")
                if len(splitAuth) == 2 </span><span class="cov1" title="1">{
                        basicAuth = client.LokiBasicAuth{
                                Login:    splitAuth[0],
                                Password: splitAuth[1],
                        }
                }</span>
        }

        <span class="cov1" title="1">l.QueryResults = make(map[string]interface{})
        resultCh := make(chan map[string][]string, len(l.Queries))
        errGroup, errCtx := errgroup.WithContext(ctx)

        for name, query := range l.Queries </span><span class="cov1" title="1">{
                errGroup.Go(func() error </span><span class="cov1" title="1">{
                        queryParams := client.LokiQueryParams{
                                Query:     query,
                                StartTime: l.StartTime,
                                EndTime:   l.EndTime,
                                Limit:     1000, //TODO make this configurable
                        }

                        parsedLokiUrl, err := url.Parse(l.Config.URL)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrapf(err, "failed to parse Loki URL %s", l.Config.URL)
                        }</span>

                        <span class="cov1" title="1">lokiUrl := parsedLokiUrl.Scheme + "://" + parsedLokiUrl.Host
                        lokiClient := client.NewLokiClient(lokiUrl, l.Config.TenantID, basicAuth, queryParams)

                        rawLogs, err := lokiClient.QueryLogs(errCtx)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrapf(err, "failed to query logs for %s", name)
                        }</span>

                        <span class="cov1" title="1">resultMap := make(map[string][]string)
                        for _, log := range rawLogs </span><span class="cov1" title="1">{
                                resultMap[name] = append(resultMap[name], log.Log)
                        }</span>

                        <span class="cov1" title="1">select </span>{
                        case resultCh &lt;- resultMap:<span class="cov1" title="1">
                                return nil</span>
                        case &lt;-errCtx.Done():<span class="cov0" title="0">
                                return errCtx.Err()</span> // Allows goroutine to exit if timeout occurs
                        }
                })
        }

        <span class="cov1" title="1">if err := errGroup.Wait(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to execute Loki queries")
        }</span>

        <span class="cov1" title="1">for i := 0; i &lt; len(l.Queries); i++ </span><span class="cov1" title="1">{
                result := &lt;-resultCh
                for name, logs := range result </span><span class="cov1" title="1">{
                        l.QueryResults[name] = logs
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}

func (l *LokiQueryExecutor) compareQueries(other map[string]string) error <span class="cov4" title="6">{
        this := l.Queries
        if len(this) != len(other) </span><span class="cov1" title="1">{
                return fmt.Errorf("queries count is different. Expected %d, got %d", len(this), len(other))
        }</span>

        <span class="cov4" title="5">for name1, query1 := range this </span><span class="cov5" title="8">{
                if query2, ok := other[name1]; !ok </span><span class="cov2" title="2">{
                        return fmt.Errorf("query %s is missing from the other report", name1)
                }</span> else<span class="cov4" title="6"> {
                        if query1 != query2 </span><span class="cov1" title="1">{
                                return fmt.Errorf("query %s is different. Expected %s, got %s", name1, query1, query2)
                        }</span>
                }
        }

        <span class="cov2" title="2">return nil</span>
}

// TimeRange sets the start and end time for the Loki query execution.
// This function is essential for defining the time window of the data to be fetched.
func (l *LokiQueryExecutor) TimeRange(start, end time.Time) <span class="cov1" title="1">{
        l.StartTime = start
        l.EndTime = end
}</span>

// UnmarshalJSON parses the JSON-encoded data and populates the LokiQueryExecutor fields.
// It converts the query results from a generic map to a specific type map, enabling type-safe access to the results.
func (l *LokiQueryExecutor) UnmarshalJSON(data []byte) error <span class="cov2" title="2">{
        // helper struct with QueryResults map[string]interface{}
        type Alias LokiQueryExecutor
        var raw struct {
                Alias
                QueryResults map[string]interface{} `json:"query_results"`
        }

        // unmarshal into the helper struct to populate other fields automatically
        if err := json.Unmarshal(data, &amp;raw); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // convert map[string]interface{} to map[string]actualType
        <span class="cov2" title="2">convertedTypes, conversionErr := convertQueryResults(raw.QueryResults)
        if conversionErr != nil </span><span class="cov0" title="0">{
                return conversionErr
        }</span>

        <span class="cov2" title="2">*l = LokiQueryExecutor(raw.Alias)
        l.QueryResults = convertedTypes
        return nil</span>
}

// NewStandardMetricsLokiExecutor creates a LokiQueryExecutor configured with standard metrics queries.
// It generates queries based on provided test parameters and time range, returning the executor or an error if query generation fails.
func NewStandardMetricsLokiExecutor(lokiConfig *wasp.LokiConfig, testName, generatorName, branch, commit string, startTime, endTime time.Time) (*LokiQueryExecutor, error) <span class="cov5" title="11">{
        lq := &amp;LokiQueryExecutor{
                KindName:     string(StandardQueryExecutor_Loki),
                Config:       lokiConfig,
                QueryResults: make(map[string]interface{}),
        }

        standardQueries, queryErr := lq.generateStandardQueries(testName, generatorName, branch, commit, startTime, endTime)
        if queryErr != nil </span><span class="cov0" title="0">{
                return nil, queryErr
        }</span>

        <span class="cov5" title="11">lq.Queries = standardQueries

        return lq, nil</span>
}

func (l *LokiQueryExecutor) standardQuery(standardMetric StandardLoadMetric, testName, generatorName, branch, commit string, startTime, endTime time.Time) (string, error) <span class="cov8" title="44">{
        // if we decide to include only plain segments for the calculation, we we will need to execute this function for each of them
        // and then aggregate the results
        queryRange := calculateTimeRange(startTime, endTime)
        switch standardMetric </span>{
        case MedianLatency:<span class="cov5" title="11">
                return fmt.Sprintf(Loki_MedianQuery, branch, commit, testName, generatorName, queryRange), nil</span>
        case Percentile95Latency:<span class="cov5" title="11">
                return fmt.Sprintf(Loki_95thQuery, branch, commit, testName, generatorName, queryRange), nil</span>
        case ErrorRate:<span class="cov5" title="11">
                return fmt.Sprintf(Loki_ErrorRate, branch, commit, testName, generatorName, queryRange), nil</span>
        case MaxLatency:<span class="cov5" title="11">
                return fmt.Sprintf(Loki_MaxQuery, branch, commit, testName, generatorName, queryRange), nil</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("unsupported standard metric %s", standardMetric)</span>
        }
}

func (l *LokiQueryExecutor) generateStandardQueries(testName, generatorName, branch, commit string, startTime, endTime time.Time) (map[string]string, error) <span class="cov5" title="11">{
        standardQueries := make(map[string]string)

        for _, metric := range StandardLoadMetrics </span><span class="cov8" title="44">{
                query, err := l.standardQuery(metric, testName, generatorName, branch, commit, startTime, endTime)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="44">standardQueries[string(metric)] = query</span>
        }

        <span class="cov5" title="11">return standardQueries, nil</span>
}

func calculateTimeRange(startTime, endTime time.Time) string <span class="cov10" title="89">{
        totalSeconds := int(endTime.Sub(startTime).Seconds())

        var rangeStr string
        if totalSeconds%3600 == 0 </span><span class="cov9" title="87">{ // Exact hours
                rangeStr = fmt.Sprintf("%dh", totalSeconds/3600)
        }</span> else<span class="cov2" title="2"> if totalSeconds%60 == 0 </span><span class="cov1" title="1">{ // Exact minutes
                rangeStr = fmt.Sprintf("%dm", totalSeconds/60)
        }</span> else<span class="cov1" title="1"> { // Use seconds for uneven intervals
                rangeStr = fmt.Sprintf("%ds", totalSeconds)
        }</span>

        <span class="cov10" title="89">return rangeStr</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package benchspy

import (
        "strconv"
)

// StringSliceToFloat64Slice converts a slice of strings to a slice of float64 values.
// It returns an error if any string cannot be parsed as a float64, making it useful for data conversion tasks.
func StringSliceToFloat64Slice(s []string) ([]float64, error) <span class="cov7" title="4">{
        numbers := make([]float64, len(s))
        for i, str := range s </span><span class="cov10" title="7">{
                var err error
                numbers[i], err = strconv.ParseFloat(str, 64)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
        }
        <span class="cov6" title="3">return numbers, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package benchspy

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "reflect"
        "time"

        "github.com/pkg/errors"
        v1 "github.com/prometheus/client_golang/api/prometheus/v1"
        "github.com/prometheus/common/model"

        "github.com/smartcontractkit/chainlink-testing-framework/lib/client"
)

// all of them are calculated over 5 minutes intervals (rate query), that are later sampled every 10 seconds over %s duration (quantile_over_time query)
var (
        Prometheus_MedianCPU = `quantile_over_time(0.5, rate(container_cpu_usage_seconds_total{name=~"%s"}[5m])[%s:10s]) * 100`
        Prometheus_P95CPU    = `quantile_over_time(0.95, rate(container_cpu_usage_seconds_total{name=~"%s"}[5m])[%s:10s]) * 100`
        Prometheus_MaxCPU    = `max(max_over_time(rate(container_cpu_usage_seconds_total{name=~"%s"}[5m])[%s:10s]) * 100)`
        Prometheus_MedianMem = `quantile_over_time(0.5, rate(container_memory_usage_bytes{name=~"%s"}[5m])[%s:10s]) * 100`
        Prometheus_P95Mem    = `quantile_over_time(0.95, rate(container_memory_usage_bytes{name=~"%s"}[5m])[%s:10s]) * 100`
        Prometheus_MaxMem    = `max(max_over_time(rate(container_memory_usage_bytes{name=~"%s"}[5m])[%s:10s]) * 100)`
)

type PrometheusConfig struct {
        Url               string
        NameRegexPatterns []string
}

const PrometheusUrlEnvVar = "PROMETHEUS_URL"

// NewPrometheusConfig creates a new PrometheusConfig instance with the specified name regex patterns.
// It retrieves the Prometheus URL from the environment and is used to configure query execution for Prometheus data sources.
func NewPrometheusConfig(nameRegexPatterns ...string) *PrometheusConfig <span class="cov3" title="3">{
        return &amp;PrometheusConfig{
                Url:               os.Getenv(PrometheusUrlEnvVar),
                NameRegexPatterns: nameRegexPatterns,
        }
}</span>

var WithoutPrometheus *PrometheusConfig = nil

type PrometheusQueryExecutor struct {
        KindName     string                 `json:"kind"`
        StartTime    time.Time              `json:"start_time"`
        EndTime      time.Time              `json:"end_time"`
        client       v1.API                 `json:"-"`
        Queries      map[string]string      `json:"queries"`
        QueryResults map[string]interface{} `json:"query_results"`
        warnings     map[string]v1.Warnings `json:"-"`
}

// NewPrometheusQueryExecutor creates a new PrometheusResourceReporter, url should include basic auth if needed
func NewPrometheusQueryExecutor(queries map[string]string, config *PrometheusConfig) (*PrometheusQueryExecutor, error) <span class="cov4" title="5">{
        c, err := client.NewPrometheusClient(config.Url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "failed to create Prometheus client")
        }</span>

        <span class="cov4" title="5">return &amp;PrometheusQueryExecutor{
                KindName:     string(StandardQueryExecutor_Prometheus),
                client:       c,
                Queries:      queries,
                QueryResults: make(map[string]interface{}),
        }, nil</span>
}

// NewStandardPrometheusQueryExecutor creates a PrometheusQueryExecutor with standard queries
// based on the provided time range and configuration. It simplifies the process of generating
// queries for Prometheus, making it easier to integrate Prometheus data into reports.
func NewStandardPrometheusQueryExecutor(startTime, endTime time.Time, config *PrometheusConfig) (*PrometheusQueryExecutor, error) <span class="cov4" title="4">{
        p := &amp;PrometheusQueryExecutor{}

        standardQueries := make(map[string]string)
        for _, nameRegexPattern := range config.NameRegexPatterns </span><span class="cov5" title="7">{
                queries, queryErr := p.generateStandardQueries(nameRegexPattern, startTime, endTime)
                if queryErr != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrapf(queryErr, "failed to generate standard queries for %s", nameRegexPattern)
                }</span>

                <span class="cov5" title="7">for name, query := range queries </span><span class="cov10" title="42">{
                        standardQueries[name] = query
                }</span>
        }

        <span class="cov4" title="4">return NewPrometheusQueryExecutor(standardQueries, config)</span>
}

// Execute runs the defined Prometheus queries concurrently, collecting results and warnings.
// It returns an error if any query fails, allowing for efficient data retrieval in reporting tasks.
func (r *PrometheusQueryExecutor) Execute(ctx context.Context) error <span class="cov3" title="3">{
        for name, query := range r.Queries </span><span class="cov3" title="3">{
                result, warnings, queryErr := r.client.Query(ctx, query, r.EndTime)
                if queryErr != nil </span><span class="cov1" title="1">{
                        return errors.Wrapf(queryErr, "failed to query Prometheus for %s", name)
                }</span>

                <span class="cov2" title="2">if len(warnings) &gt; 0 </span><span class="cov1" title="1">{
                        r.warnings[name] = warnings
                }</span>

                <span class="cov2" title="2">r.QueryResults[name] = result</span>
        }

        <span class="cov2" title="2">return nil</span>
}

// Results returns the query results as a map of string to interface{}.
// It allows users to access the results of executed queries, facilitating data retrieval and manipulation.
func (r *PrometheusQueryExecutor) Results() map[string]interface{} <span class="cov3" title="3">{
        return r.QueryResults
}</span>

// Kind returns the type of the query executor as a string.
// It is used to identify the specific kind of executor in a collection of query executors.
func (l *PrometheusQueryExecutor) Kind() string <span class="cov0" title="0">{
        return l.KindName
}</span>

// Validate checks the PrometheusQueryExecutor for a valid client and ensures that at least one query is provided.
// It returns an error if the client is nil or no queries are specified, helping to ensure proper configuration before execution.
func (r *PrometheusQueryExecutor) Validate() error <span class="cov5" title="6">{
        if r.client == nil </span><span class="cov1" title="1">{
                return errors.New("prometheus client is nil")
        }</span>

        <span class="cov4" title="5">if len(r.Queries) == 0 </span><span class="cov1" title="1">{
                return errors.New("no queries provided")
        }</span>

        <span class="cov4" title="4">return nil</span>
}

// IsComparable checks if the provided QueryExecutor is of the same type as the receiver.
// It returns an error if the types do not match, ensuring type safety for query comparisons.
func (r *PrometheusQueryExecutor) IsComparable(other QueryExecutor) error <span class="cov4" title="5">{
        otherType := reflect.TypeOf(other)
        if otherType != reflect.TypeOf(r) </span><span class="cov1" title="1">{
                return fmt.Errorf("expected type %s, got %s", reflect.TypeOf(r), otherType)
        }</span>

        <span class="cov4" title="4">asPrometheusResourceReporter := other.(*PrometheusQueryExecutor)

        return r.compareQueries(asPrometheusResourceReporter.Queries)</span>
}

func (r *PrometheusQueryExecutor) compareQueries(other map[string]string) error <span class="cov4" title="4">{
        this := r.Queries
        if len(this) != len(other) </span><span class="cov1" title="1">{
                return fmt.Errorf("queries count is different. Expected %d, got %d", len(this), len(other))
        }</span>

        <span class="cov3" title="3">for name1, query1 := range this </span><span class="cov4" title="5">{
                if query2, ok := other[name1]; !ok </span><span class="cov1" title="1">{
                        return fmt.Errorf("query %s is missing from the other report", name1)
                }</span> else<span class="cov4" title="4"> {
                        if query1 != query2 </span><span class="cov1" title="1">{
                                return fmt.Errorf("query %s is different. Expected %s, got %s", name1, query1, query2)
                        }</span>
                }
        }

        <span class="cov1" title="1">return nil</span>
}

// Warnings returns a map of warnings encountered during query execution.
// This function is useful for retrieving any issues that may have arisen,
// allowing users to handle or log them appropriately.
func (r *PrometheusQueryExecutor) Warnings() map[string]v1.Warnings <span class="cov2" title="2">{
        return r.warnings
}</span>

// MustResultsAsValue retrieves the query results as a map of metric names to their corresponding values.
// It ensures that the results are in a consistent format, making it easier to work with metrics in subsequent operations.
func (r *PrometheusQueryExecutor) MustResultsAsValue() map[string]model.Value <span class="cov4" title="4">{
        results := make(map[string]model.Value)
        for name, result := range r.QueryResults </span><span class="cov4" title="4">{
                var val model.Value
                switch v := result.(type) </span>{
                case model.Matrix:<span class="cov1" title="1">
                        // model.Matrix implements model.Value with value receivers
                        val = v</span>
                case *model.Matrix:<span class="cov0" title="0">
                        val = v</span>
                case model.Vector:<span class="cov1" title="1">
                        // model.Vector implements model.Value with value receivers
                        val = v</span>
                case *model.Vector:<span class="cov1" title="1">
                        val = v</span>
                case model.Scalar:<span class="cov0" title="0">
                        scalar := v
                        // *model.Scalar implements model.Value
                        val = &amp;scalar</span>
                case *model.Scalar:<span class="cov1" title="1">
                        val = v</span>
                case model.String:<span class="cov0" title="0">
                        str := v
                        // *model.String implements model.Value
                        val = &amp;str</span>
                case *model.String:<span class="cov0" title="0">
                        val = v</span>
                default:<span class="cov0" title="0">
                        panic(fmt.Sprintf("Unknown result type: %T", result))</span>
                }
                <span class="cov4" title="4">results[name] = val</span>
        }
        <span class="cov4" title="4">return results</span>
}

// TimeRange sets the start and end time for the Prometheus query execution.
// This function is essential for defining the time window for data retrieval, ensuring accurate and relevant results.
func (r *PrometheusQueryExecutor) TimeRange(startTime, endTime time.Time) <span class="cov0" title="0">{
        r.StartTime = startTime
        r.EndTime = endTime
}</span>

func (r *PrometheusQueryExecutor) standardQuery(metric StandardResourceMetric, nameRegexPattern string, startTime, endTime time.Time) (string, error) <span class="cov10" title="42">{
        duration := calculateTimeRange(startTime, endTime)
        switch metric </span>{
        case MedianCPUUsage:<span class="cov5" title="7">
                return fmt.Sprintf(Prometheus_MedianCPU, nameRegexPattern, duration), nil</span>
        case P95CPUUsage:<span class="cov5" title="7">
                return fmt.Sprintf(Prometheus_P95CPU, nameRegexPattern, duration), nil</span>
        case MaxCPUUsage:<span class="cov5" title="7">
                return fmt.Sprintf(Prometheus_MaxCPU, nameRegexPattern, duration), nil</span>
        case MedianMemUsage:<span class="cov5" title="7">
                return fmt.Sprintf(Prometheus_MedianMem, nameRegexPattern, duration), nil</span>
        case P95MemUsage:<span class="cov5" title="7">
                return fmt.Sprintf(Prometheus_P95Mem, nameRegexPattern, duration), nil</span>
        case MaxMemUsage:<span class="cov5" title="7">
                return fmt.Sprintf(Prometheus_MaxMem, nameRegexPattern, duration), nil</span>
        default:<span class="cov0" title="0">
                return "", fmt.Errorf("unsupported standard metric %s", metric)</span>
        }
}

func (r *PrometheusQueryExecutor) generateStandardQueries(nameRegexPattern string, startTime, endTime time.Time) (map[string]string, error) <span class="cov5" title="7">{
        standardQueries := make(map[string]string)

        for _, metric := range StandardResourceMetrics </span><span class="cov10" title="42">{
                query, err := r.standardQuery(metric, nameRegexPattern, startTime, endTime)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov10" title="42">standardQueries[string(metric)] = query</span>
        }

        <span class="cov5" title="7">return standardQueries, nil</span>
}

type TypedMetric struct {
        Value      model.Value `json:"value"`
        MetricType string      `json:"metric_type"`
}

// MarshalJSON customizes the JSON representation of PrometheusQueryExecutor.
// It includes only essential fields: Kind, Queries, and simplified QueryResults.
// This function is useful for serializing the executor's state in a concise format.
func (g *PrometheusQueryExecutor) MarshalJSON() ([]byte, error) <span class="cov1" title="1">{
        // we need custom marshalling to only include some parts of the metrics
        type QueryExecutor struct {
                Kind         string                 `json:"kind"`
                Queries      map[string]string      `json:"queries"`
                QueryResults map[string]TypedMetric `json:"query_results"`
        }

        q := &amp;QueryExecutor{
                Kind:    g.KindName,
                Queries: g.Queries,
                QueryResults: func() map[string]TypedMetric </span><span class="cov1" title="1">{
                        simplifiedMetrics := make(map[string]TypedMetric)
                        for name, value := range g.MustResultsAsValue() </span><span class="cov1" title="1">{
                                simplifiedMetrics[name] = TypedMetric{
                                        MetricType: value.Type().String(),
                                        Value:      value,
                                }
                        }</span>
                        <span class="cov1" title="1">return simplifiedMetrics</span>
                }(),
        }

        <span class="cov1" title="1">return json.Marshal(q)</span>
}

// UnmarshalJSON decodes JSON data into a PrometheusQueryExecutor instance.
// It populates the QueryResults field with appropriately typed metrics,
// enabling easy access to the results of Prometheus queries.
func (r *PrometheusQueryExecutor) UnmarshalJSON(data []byte) error <span class="cov4" title="4">{
        // helper struct with QueryResults map[string]interface{}
        type Alias PrometheusQueryExecutor
        var raw struct {
                Alias
                QueryResults map[string]json.RawMessage `json:"query_results"`
        }

        // unmarshal into the helper struct to populate other fields automatically
        if err := json.Unmarshal(data, &amp;raw); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="4">var convertedQueryResults = make(map[string]interface{})

        for name, rawResult := range raw.QueryResults </span><span class="cov4" title="4">{
                var rawTypedMetric struct {
                        MetricType string          `json:"metric_type"`
                        Value      json.RawMessage `json:"value"`
                }
                if err := json.Unmarshal(rawResult, &amp;rawTypedMetric); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrapf(err, "failed to unmarshal query result for %s", name)
                }</span>

                <span class="cov4" title="4">switch rawTypedMetric.MetricType </span>{
                case "scalar":<span class="cov1" title="1">
                        var scalar model.Scalar
                        if err := json.Unmarshal(rawTypedMetric.Value, &amp;scalar); err != nil </span><span class="cov0" title="0">{
                                return errors.Wrapf(err, "failed to unmarshal scalar value for %s", name)
                        }</span>
                        <span class="cov1" title="1">convertedQueryResults[name] = &amp;scalar</span>
                case "vector":<span class="cov2" title="2">
                        var vector model.Vector
                        if err := json.Unmarshal(rawTypedMetric.Value, &amp;vector); err != nil </span><span class="cov0" title="0">{
                                return errors.Wrapf(err, "failed to unmarshal vector value for %s", name)
                        }</span>
                        <span class="cov2" title="2">convertedQueryResults[name] = vector</span>
                case "matrix":<span class="cov1" title="1">
                        var matrix model.Matrix
                        if err := json.Unmarshal(rawTypedMetric.Value, &amp;matrix); err != nil </span><span class="cov0" title="0">{
                                return errors.Wrapf(err, "failed to unmarshal matrix value for %s", name)
                        }</span>
                        <span class="cov1" title="1">convertedQueryResults[name] = matrix</span>
                case "string":<span class="cov0" title="0">
                        var str model.String
                        if err := json.Unmarshal(rawTypedMetric.Value, &amp;str); err != nil </span><span class="cov0" title="0">{
                                return errors.Wrapf(err, "failed to unmarshal string value for %s", name)
                        }</span>
                        <span class="cov0" title="0">convertedQueryResults[name] = &amp;str</span>
                default:<span class="cov0" title="0">
                        return fmt.Errorf("unknown metric type %s", rawTypedMetric.MetricType)</span>
                }
        }

        <span class="cov4" title="4">*r = PrometheusQueryExecutor(raw.Alias)
        r.QueryResults = convertedQueryResults
        return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package benchspy

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"

        "github.com/pkg/errors"
        "github.com/prometheus/common/model"
        "github.com/smartcontractkit/chainlink-testing-framework/wasp"
        "golang.org/x/sync/errgroup"
)

// StandardReport is a report that contains all the necessary data for a performance test
type StandardReport struct {
        BasicData
        LocalStorage
        QueryExecutors []QueryExecutor `json:"query_executors"`
}

// Store saves the report to local storage as a JSON file.
// It returns the absolute path of the stored file and any error encountered.
func (b *StandardReport) Store() (string, error) <span class="cov2" title="2">{
        return b.LocalStorage.Store(b.TestName, b.CommitOrTag, b)
}</span>

// Load retrieves a report based on the specified test name and commit or tag.
// It utilizes local storage to find and decode the corresponding report file,
// ensuring that the report is available for further processing or analysis.
func (b *StandardReport) Load(testName, commitOrTag string) error <span class="cov1" title="1">{
        return b.LocalStorage.Load(testName, commitOrTag, b)
}</span>

// LoadLatest retrieves the most recent report for the specified test name from local storage.
// It returns an error if the report cannot be loaded, enabling users to access historical test data efficiently.
func (b *StandardReport) LoadLatest(testName string) error <span class="cov2" title="2">{
        return b.LocalStorage.Load(testName, "", b)
}</span>

// ResultsAs retrieves and casts results from specified query executors to a desired type.
// It returns a map of query names to their corresponding results, or an error if casting fails.
func ResultsAs[Type any](newType Type, queryExecutors []QueryExecutor, queryExecutorType StandardQueryExecutorType, queryNames ...string) (map[string]Type, error) <span class="cov8" title="23">{
        results := make(map[string]Type)

        for _, queryExecutor := range queryExecutors </span><span class="cov8" title="25">{
                if strings.EqualFold(queryExecutor.Kind(), string(queryExecutorType)) </span><span class="cov8" title="23">{
                        if len(queryNames) &gt; 0 </span><span class="cov4" title="4">{
                                for _, queryName := range queryNames </span><span class="cov5" title="7">{
                                        if result, ok := queryExecutor.Results()[queryName]; ok </span><span class="cov5" title="7">{
                                                if asType, ok := result.(Type); ok </span><span class="cov5" title="7">{
                                                        results[queryName] = asType
                                                }</span> else<span class="cov0" title="0"> {
                                                        return nil, fmt.Errorf("failed to cast result to type %T. It's actual type is: %T", newType, result)
                                                }</span>
                                        }
                                }
                        } else<span class="cov7" title="19"> {
                                for queryName, result := range queryExecutor.Results() </span><span class="cov10" title="52">{
                                        if asType, ok := result.(Type); ok </span><span class="cov9" title="50">{
                                                results[queryName] = asType
                                        }</span> else<span class="cov2" title="2"> {
                                                return nil, fmt.Errorf("failed to cast result to type %T. It's actual type is: %T", newType, result)
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov7" title="21">return results, nil</span>
}

// MustAllLokiResults retrieves all Loki query results from a StandardReport.
// It panics if an error occurs during the retrieval process, ensuring that
// the caller receives valid results or an immediate failure.
func MustAllLokiResults(sr *StandardReport) map[string][]string <span class="cov3" title="3">{
        results, err := ResultsAs([]string{}, sr.QueryExecutors, StandardQueryExecutor_Loki)
        if err != nil </span><span class="cov1" title="1">{
                panic(err)</span>
        }
        <span class="cov2" title="2">return results</span>
}

// MustAllDirectResults retrieves all direct results from a StandardReport.
// It panics if an error occurs during the retrieval process, ensuring that
// the caller receives valid results or an immediate failure.
func MustAllDirectResults(sr *StandardReport) map[string]float64 <span class="cov7" title="15">{
        results, err := ResultsAs(0.0, sr.QueryExecutors, StandardQueryExecutor_Direct)
        if err != nil </span><span class="cov1" title="1">{
                panic(err)</span>
        }
        <span class="cov7" title="14">return results</span>
}

// MustAllPrometheusResults retrieves all Prometheus query results from a StandardReport.
// It returns a map of query names to their corresponding model.Values, ensuring type safety.
// This function is useful for aggregating and accessing Prometheus metrics efficiently.
func MustAllPrometheusResults(sr *StandardReport) map[string]model.Value <span class="cov1" title="1">{
        results := make(map[string]model.Value)

        for _, queryExecutor := range sr.QueryExecutors </span><span class="cov1" title="1">{
                if strings.EqualFold(queryExecutor.Kind(), string(StandardQueryExecutor_Prometheus)) </span><span class="cov1" title="1">{
                        for queryName, result := range queryExecutor.Results() </span><span class="cov2" title="2">{
                                if asValue, ok := result.(model.Value); ok </span><span class="cov2" title="2">{
                                        results[queryName] = asValue
                                }</span>
                        }
                }
        }

        <span class="cov1" title="1">return results</span>
}

func CompareDirectWithThresholds(medianThreshold, p95Threshold, maxThreshold, errorRateThreshold float64, previousReport, currentReport *StandardReport) (bool, []error) <span class="cov5" title="6">{
        currentResults := MustAllDirectResults(currentReport)
        previousResults := MustAllDirectResults(previousReport)

        var compareValues = func(
                metricName string,
                maxDiffPercentage float64,
        ) error </span><span class="cov8" title="24">{
                if _, ok := currentResults[metricName]; !ok </span><span class="cov3" title="3">{
                        return fmt.Errorf("%s results were missing from current report", metricName)
                }</span>

                <span class="cov7" title="21">if _, ok := previousResults[metricName]; !ok </span><span class="cov0" title="0">{
                        return fmt.Errorf("%s results were missing from previous report", metricName)
                }</span>

                <span class="cov7" title="21">currentMetric := currentResults[metricName]
                previousMetric := previousResults[metricName]

                var diffPrecentage float64
                if previousMetric != 0.0 &amp;&amp; currentMetric != 0.0 </span><span class="cov6" title="13">{
                        diffPrecentage = (currentMetric - previousMetric) / previousMetric * 100
                }</span> else<span class="cov5" title="8"> if previousMetric == 0.0 &amp;&amp; currentMetric == 0.0 </span><span class="cov4" title="4">{
                        diffPrecentage = 0.0
                }</span> else<span class="cov4" title="4"> {
                        diffPrecentage = 100.0
                }</span>

                <span class="cov7" title="21">if diffPrecentage &gt; maxDiffPercentage </span><span class="cov6" title="9">{
                        return fmt.Errorf("%s medians are %.4f%% different, which is higher than the threshold %.4f%%", metricName, diffPrecentage, maxDiffPercentage)
                }</span>

                <span class="cov6" title="12">return nil</span>
        }

        <span class="cov5" title="6">var errors []error

        if err := compareValues(string(MedianLatency), medianThreshold); err != nil </span><span class="cov3" title="3">{
                errors = append(errors, err)
        }</span>

        <span class="cov5" title="6">if err := compareValues(string(Percentile95Latency), p95Threshold); err != nil </span><span class="cov3" title="3">{
                errors = append(errors, err)
        }</span>

        <span class="cov5" title="6">if err := compareValues(string(MaxLatency), maxThreshold); err != nil </span><span class="cov3" title="3">{
                errors = append(errors, err)
        }</span>

        <span class="cov5" title="6">if err := compareValues(string(ErrorRate), errorRateThreshold); err != nil </span><span class="cov3" title="3">{
                errors = append(errors, err)
        }</span>

        <span class="cov5" title="6">return len(errors) &gt; 0, errors</span>
}

// FetchData retrieves data for the report within the specified time range.
// It validates the time range and executes queries in parallel, returning any errors encountered during execution.
func (b *StandardReport) FetchData(ctx context.Context) error <span class="cov5" title="6">{
        if b.TestStart.IsZero() || b.TestEnd.IsZero() </span><span class="cov0" title="0">{
                return errors.New("start and end times are not set")
        }</span>

        <span class="cov5" title="6">errGroup, errCtx := errgroup.WithContext(ctx)
        for _, queryExecutor := range b.QueryExecutors </span><span class="cov6" title="10">{
                errGroup.Go(func() error </span><span class="cov6" title="10">{
                        // feature: PLAIN SEGEMENT ONLY
                        // go over all schedules and execute the code below only for ones with type "plain"
                        // and then concatenate that data and return that; if parallelizing then we should first
                        // create a slice of plain segments and then, when sending results over channel include the index,
                        // so that we can concatenate them in the right order
                        queryExecutor.TimeRange(b.TestStart, b.TestEnd)

                        // in case someone skipped helper functions and didn't set the start and end times
                        if validateErr := queryExecutor.Validate(); validateErr != nil </span><span class="cov0" title="0">{
                                return validateErr
                        }</span>

                        <span class="cov6" title="10">if execErr := queryExecutor.Execute(errCtx); execErr != nil </span><span class="cov3" title="3">{
                                return execErr
                        }</span>

                        <span class="cov5" title="7">return nil</span>
                })
        }

        <span class="cov5" title="6">if err := errGroup.Wait(); err != nil </span><span class="cov3" title="3">{
                return err
        }</span>

        <span class="cov3" title="3">return nil</span>
}

// IsComparable checks if the current report can be compared with another report.
// It validates the type of the other report and ensures that their basic data and query executors are comparable.
// This function is useful for verifying report consistency before performing further analysis.
func (b *StandardReport) IsComparable(otherReport Reporter) error <span class="cov4" title="4">{
        if _, ok := otherReport.(*StandardReport); !ok </span><span class="cov1" title="1">{
                return fmt.Errorf("expected type %s, got %T", "*StandardReport", otherReport)
        }</span>

        <span class="cov3" title="3">asStandardReport := otherReport.(*StandardReport)

        basicErr := b.BasicData.IsComparable(asStandardReport.BasicData)
        if basicErr != nil </span><span class="cov1" title="1">{
                return basicErr
        }</span>

        <span class="cov2" title="2">for _, queryExecutor := range b.QueryExecutors </span><span class="cov2" title="2">{
                queryErr := queryExecutor.IsComparable(queryExecutor)
                if queryErr != nil </span><span class="cov0" title="0">{
                        return queryErr
                }</span>
        }

        <span class="cov2" title="2">return nil</span>
}

type standardReportConfig struct {
        executorTypes    []StandardQueryExecutorType
        generators       []*wasp.Generator
        prometheusConfig *PrometheusConfig
        queryExecutors   []QueryExecutor
        reportDirectory  string
}

type StandardReportOption func(*standardReportConfig)

// WithStandardQueries sets the executor types for a standard report configuration.
// It allows users to specify which types of query executors to use, enabling customization
// of report generation based on their requirements.
func WithStandardQueries(executorTypes ...StandardQueryExecutorType) StandardReportOption <span class="cov7" title="20">{
        return func(c *standardReportConfig) </span><span class="cov8" title="22">{
                c.executorTypes = executorTypes
        }</span>
}

// WithGenerators sets the generators for the standard report configuration.
// It allows users to specify custom generator instances to be included in the report.
func WithGenerators(generators ...*wasp.Generator) StandardReportOption <span class="cov7" title="19">{
        return func(c *standardReportConfig) </span><span class="cov7" title="21">{
                c.generators = generators
        }</span>
}

// WithPrometheusConfig sets the Prometheus configuration for the standard report.
// It returns a StandardReportOption that can be used to customize report generation.
func WithPrometheusConfig(prometheusConfig *PrometheusConfig) StandardReportOption <span class="cov4" title="4">{
        return func(c *standardReportConfig) </span><span class="cov4" title="4">{
                c.prometheusConfig = prometheusConfig
        }</span>
}

// WithReportDirectory sets the directory for storing report files.
// This function is useful for configuring the output location of reports
// generated by the standard reporting system.
func WithReportDirectory(reportDirectory string) StandardReportOption <span class="cov3" title="3">{
        return func(c *standardReportConfig) </span><span class="cov4" title="5">{
                c.reportDirectory = reportDirectory
        }</span>
}

// WithQueryExecutors sets the query executors for a standard report configuration.
// It allows customization of how queries are executed, enhancing report generation flexibility.
func WithQueryExecutors(queryExecutors ...QueryExecutor) StandardReportOption <span class="cov0" title="0">{
        return func(c *standardReportConfig) </span><span class="cov0" title="0">{
                c.queryExecutors = queryExecutors
        }</span>
}

func (c *standardReportConfig) validate() error <span class="cov7" title="19">{
        if len(c.executorTypes) == 0 &amp;&amp; len(c.queryExecutors) == 0 </span><span class="cov0" title="0">{
                return errors.New("no standard executor types and no custom query executors are provided. At least one is needed")
        }</span>

        <span class="cov7" title="19">hasPrometehus := false
        for _, t := range c.executorTypes </span><span class="cov7" title="20">{
                if t == StandardQueryExecutor_Prometheus </span><span class="cov4" title="4">{
                        hasPrometehus = true
                        if c.prometheusConfig == WithoutPrometheus </span><span class="cov0" title="0">{
                                return errors.New("prometheus as query executor type is set, but prometheus config is not provided")
                        }</span>
                }
        }

        <span class="cov7" title="19">if len(c.generators) == 0 </span><span class="cov0" title="0">{
                return errors.New("generators are not set, at least one is required")
        }</span>

        <span class="cov7" title="19">if c.prometheusConfig != WithoutPrometheus </span><span class="cov4" title="4">{
                if !hasPrometehus </span><span class="cov0" title="0">{
                        return errors.New("prometheus config is set, but query executor type is not set to prometheus")
                }</span>

                <span class="cov4" title="4">if c.prometheusConfig.Url == "" </span><span class="cov1" title="1">{
                        return errors.New("prometheus url is not set")
                }</span>
                <span class="cov3" title="3">if len(c.prometheusConfig.NameRegexPatterns) == 0 </span><span class="cov1" title="1">{
                        return errors.New("prometheus name regex patterns are not set. At least one pattern is needed to match containers by name")
                }</span>
        }

        <span class="cov7" title="17">return nil</span>
}

// NewStandardReport creates a new StandardReport based on the provided commit or tag and options.
// It initializes necessary data and query executors, ensuring all configurations are validated.
// This function is essential for generating reports that require specific data sources and execution strategies.
func NewStandardReport(commitOrTag string, opts ...StandardReportOption) (*StandardReport, error) <span class="cov7" title="20">{
        config := standardReportConfig{}
        for _, opt := range opts </span><span class="cov9" title="46">{
                opt(&amp;config)
        }</span>

        <span class="cov7" title="20">basicData, basicErr := NewBasicData(commitOrTag, config.generators...)
        if basicErr != nil </span><span class="cov1" title="1">{
                var generatorNames string
                for _, g := range config.generators </span><span class="cov0" title="0">{
                        generatorNames += g.Cfg.GenName + ", "
                }</span>
                <span class="cov1" title="1">return nil, errors.Wrapf(basicErr, "failed to create basic data for generators %s", generatorNames)</span>
        }

        <span class="cov7" title="19">configErr := config.validate()
        if configErr != nil </span><span class="cov2" title="2">{
                return nil, configErr
        }</span>

        <span class="cov7" title="17">basicValidateErr := basicData.Validate()
        if basicValidateErr != nil </span><span class="cov0" title="0">{
                return nil, basicValidateErr
        }</span>

        <span class="cov7" title="17">var queryExecutors []QueryExecutor
        if len(config.executorTypes) != 0 </span><span class="cov7" title="17">{
                for _, g := range config.generators </span><span class="cov7" title="17">{
                        for _, exType := range config.executorTypes </span><span class="cov7" title="18">{
                                if exType != StandardQueryExecutor_Prometheus </span><span class="cov7" title="16">{
                                        executor, executorErr := initStandardQueryExecutor(exType, basicData, g)
                                        if executorErr != nil </span><span class="cov2" title="2">{
                                                return nil, errors.Wrapf(executorErr, "failed to create standard %s query executor for generator %s", exType, g.Cfg.GenName)
                                        }</span>

                                        <span class="cov7" title="14">validateErr := executor.Validate()
                                        if validateErr != nil </span><span class="cov1" title="1">{
                                                return nil, errors.Wrapf(validateErr, "failed to validate queries for generator %s", g.Cfg.GenName)
                                        }</span>

                                        <span class="cov6" title="13">queryExecutors = append(queryExecutors, executor)</span>
                                }
                        }
                }
        }

        <span class="cov7" title="14">if len(config.queryExecutors) &gt; 0 </span><span class="cov0" title="0">{
                queryExecutors = append(queryExecutors, config.queryExecutors...)
        }</span>

        <span class="cov7" title="14">if config.prometheusConfig != WithoutPrometheus </span><span class="cov2" title="2">{
                // not ideal, but we want to follow the same pattern as with other executors
                for _, n := range config.prometheusConfig.NameRegexPatterns </span><span class="cov3" title="3">{
                        prometheusExecutor, prometheusErr := NewStandardPrometheusQueryExecutor(basicData.TestStart, basicData.TestEnd, NewPrometheusConfig(config.prometheusConfig.Url, n))
                        if prometheusErr != nil </span><span class="cov0" title="0">{
                                return nil, errors.Wrapf(prometheusErr, "failed to create Prometheus executor for name patterns: %s", strings.Join(config.prometheusConfig.NameRegexPatterns, ", "))
                        }</span>
                        <span class="cov3" title="3">validateErr := prometheusExecutor.Validate()
                        if validateErr != nil </span><span class="cov0" title="0">{
                                return nil, errors.Wrapf(validateErr, "failed to Prometheus executor for for name patterns: %s", strings.Join(config.prometheusConfig.NameRegexPatterns, ", "))
                        }</span>
                        <span class="cov3" title="3">queryExecutors = append(queryExecutors, prometheusExecutor)</span>
                }
        }

        <span class="cov7" title="14">sr := &amp;StandardReport{
                BasicData:      *basicData,
                QueryExecutors: queryExecutors,
        }

        if config.reportDirectory != "" </span><span class="cov3" title="3">{
                sr.LocalStorage.Directory = config.reportDirectory
        }</span>

        <span class="cov7" title="14">return sr, nil</span>
}

func initStandardQueryExecutor(kind StandardQueryExecutorType, basicData *BasicData, g *wasp.Generator) (QueryExecutor, error) <span class="cov7" title="16">{
        switch kind </span>{
        case StandardQueryExecutor_Loki:<span class="cov6" title="12">
                if !generatorHasLabels(g) </span><span class="cov2" title="2">{
                        return nil, fmt.Errorf("generator %s is missing branch or commit labels", g.Cfg.GenName)
                }</span>
                <span class="cov6" title="10">executor, executorErr := NewStandardMetricsLokiExecutor(g.Cfg.LokiConfig, basicData.TestName, g.Cfg.GenName, g.Cfg.Labels["branch"], g.Cfg.Labels["commit"], basicData.TestStart, basicData.TestEnd)
                if executorErr != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrapf(executorErr, "failed to create standard Loki query executor for generator %s", g.Cfg.GenName)
                }</span>
                <span class="cov6" title="10">return executor, nil</span>
        case StandardQueryExecutor_Direct:<span class="cov4" title="4">
                executor, executorErr := NewStandardDirectQueryExecutor(g)
                if executorErr != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrapf(executorErr, "failed to create standard generator query executor for generator %s", g.Cfg.GenName)
                }</span>
                <span class="cov4" title="4">return executor, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unknown standard query executor type: %s", kind)</span>
        }
}

func generatorHasLabels(g *wasp.Generator) bool <span class="cov6" title="12">{
        return g.Cfg.Labels["branch"] != "" &amp;&amp; g.Cfg.Labels["commit"] != ""
}</span>

// UnmarshalJSON decodes JSON data into a StandardReport struct.
// It populates the QueryExecutors and ResourceFetchers fields,
// allowing for dynamic handling of JSON structures in reports.
func (s *StandardReport) UnmarshalJSON(data []byte) error <span class="cov5" title="8">{
        // helper struct with QueryExecutors as json.RawMessage
        type Alias StandardReport
        var raw struct {
                Alias
                QueryExecutors   []json.RawMessage `json:"query_executors"`
                ResourceFetchers []json.RawMessage `json:"resource_fetchers"`
        }

        // unmarshal into the helper struct to populate other fields automatically
        if err := json.Unmarshal(data, &amp;raw); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov5" title="8">queryExecutors, queryErr := unmarshallQueryExecutors(raw.QueryExecutors)
        if queryErr != nil </span><span class="cov1" title="1">{
                return queryErr
        }</span>

        <span class="cov5" title="7">*s = StandardReport(raw.Alias)
        s.QueryExecutors = queryExecutors
        return nil</span>
}

func unmarshallQueryExecutors(raw []json.RawMessage) ([]QueryExecutor, error) <span class="cov5" title="8">{
        var queryExecutors []QueryExecutor

        // manually decide, which QueryExecutor implementation to use based on the "kind" field
        for _, rawExecutor := range raw </span><span class="cov5" title="8">{
                var typeIndicator struct {
                        Kind string `json:"kind"`
                }
                if err := json.Unmarshal(rawExecutor, &amp;typeIndicator); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // each new implementation of QueryExecutor might need a custom JSON unmarshaller
                // especially if it's using interface{} fields and when unmarhsalling you would like them
                // to have actual types (e.g. []string instead of []interface{}) as that will help
                // with type safety and readability
                <span class="cov5" title="8">var executor QueryExecutor
                switch typeIndicator.Kind </span>{
                case "loki":<span class="cov2" title="2">
                        executor = &amp;LokiQueryExecutor{}</span>
                case "direct":<span class="cov2" title="2">
                        executor = &amp;DirectQueryExecutor{}</span>
                case "prometheus":<span class="cov3" title="3">
                        executor = &amp;PrometheusQueryExecutor{}</span>
                default:<span class="cov1" title="1">
                        return nil, fmt.Errorf("unknown query executor type: %s\nIf you added a new query executor make sure to add a custom JSON unmarshaller to StandardReport.UnmarshalJSON()", typeIndicator.Kind)</span>
                }

                <span class="cov5" title="7">if unmarshalErr := json.Unmarshal(rawExecutor, executor); unmarshalErr != nil </span><span class="cov0" title="0">{
                        return nil, unmarshalErr
                }</span>

                <span class="cov5" title="7">queryExecutors = append(queryExecutors, executor)</span>
        }

        <span class="cov5" title="7">return queryExecutors, nil</span>
}

func convertQueryResults(results map[string]interface{}) (map[string]interface{}, error) <span class="cov7" title="17">{
        converted := make(map[string]interface{})

        for key, value := range results </span><span class="cov7" title="17">{
                switch v := value.(type) </span>{
                case string, int, float64:<span class="cov5" title="6">
                        converted[key] = v</span>
                case []interface{}:<span class="cov5" title="8">
                        if len(v) == 0 </span><span class="cov0" title="0">{
                                converted[key] = v
                                continue</span>
                        }
                        // Convert first element to determine slice type
                        <span class="cov5" title="8">switch v[0].(type) </span>{
                        case string:<span class="cov4" title="4">
                                strSlice := make([]string, len(v))
                                allConverted := true
                                for i, elem := range v </span><span class="cov6" title="11">{
                                        str, ok := elem.(string)
                                        if !ok </span><span class="cov1" title="1">{
                                                // return original slice if we can't convert, because its composed of different types
                                                converted[key] = v
                                                allConverted = false
                                                break</span>
                                        }
                                        <span class="cov6" title="10">strSlice[i] = str</span>
                                }
                                <span class="cov4" title="4">if allConverted </span><span class="cov3" title="3">{
                                        converted[key] = strSlice
                                }</span>
                        case int:<span class="cov2" title="2">
                                intSlice := make([]int, len(v))
                                allConverted := true
                                for i, elem := range v </span><span class="cov4" title="5">{
                                        num, ok := elem.(int)
                                        if !ok </span><span class="cov1" title="1">{
                                                // return original slice if we can't convert, because its composed of different types
                                                converted[key] = v
                                                allConverted = false
                                                break</span>
                                        }
                                        <span class="cov4" title="4">intSlice[i] = num</span>
                                }
                                <span class="cov2" title="2">if allConverted </span><span class="cov1" title="1">{
                                        converted[key] = intSlice
                                }</span>
                        case float64:<span class="cov2" title="2">
                                floatSlice := make([]float64, len(v))
                                allConverted := true
                                for i, elem := range v </span><span class="cov4" title="5">{
                                        f, ok := elem.(float64)
                                        if !ok </span><span class="cov1" title="1">{
                                                // return original slice if we can't convert, because its composed of different types
                                                converted[key] = v
                                                allConverted = false
                                                break</span>
                                        }
                                        <span class="cov4" title="4">floatSlice[i] = f</span>
                                }
                                <span class="cov2" title="2">if allConverted </span><span class="cov1" title="1">{
                                        converted[key] = floatSlice
                                }</span>
                        default:<span class="cov0" title="0">
                                // do nothing if it's not a type we can convert
                                converted[key] = v</span>
                        }
                default:<span class="cov3" title="3">
                        // do nothing if it's not a type we can convert
                        converted[key] = v</span>
                }
        }
        <span class="cov7" title="17">return converted, nil</span>
}

// FetchNewStandardReportAndLoadLatestPrevious creates a new standard report for a given commit or tag,
// loads the latest previous report, and checks their comparability.
// It returns the new report, the previous report, and any error encountered during the process.
func FetchNewStandardReportAndLoadLatestPrevious(ctx context.Context, newCommitOrTag string, newReportOpts ...StandardReportOption) (*StandardReport, *StandardReport, error) <span class="cov2" title="2">{
        newReport, err := NewStandardReport(newCommitOrTag, newReportOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errors.Wrapf(err, "failed to create new report for commit or tag %s", newCommitOrTag)
        }</span>

        <span class="cov2" title="2">config := standardReportConfig{}
        for _, opt := range newReportOpts </span><span class="cov5" title="6">{
                opt(&amp;config)
        }</span>

        <span class="cov2" title="2">var localStorage LocalStorage

        if config.reportDirectory != "" </span><span class="cov2" title="2">{
                localStorage.Directory = config.reportDirectory
        }</span>

        <span class="cov2" title="2">previousReport := &amp;StandardReport{
                LocalStorage: localStorage,
        }

        if err = previousReport.LoadLatest(newReport.TestName); err != nil </span><span class="cov1" title="1">{
                return nil, nil, errors.Wrapf(err, "failed to load latest report for test %s", newReport.TestName)
        }</span>

        <span class="cov1" title="1">if err = newReport.FetchData(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, nil, errors.Wrapf(err, "failed to fetch data for new report")
        }</span>

        <span class="cov1" title="1">err = newReport.IsComparable(previousReport)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errors.Wrapf(err, "new report is not comparable to previous report")
        }</span>

        <span class="cov1" title="1">return newReport, previousReport, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package benchspy

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "os/exec"
        "path/filepath"
        "strings"

        "github.com/pkg/errors"
)

const DEFAULT_DIRECTORY = "performance_reports"

type LocalStorage struct {
        Directory string `json:"directory"`
}

func (l *LocalStorage) defaultDirectoryIfEmpty() <span class="cov10" title="43">{
        if l.Directory == "" </span><span class="cov1" title="1">{
                l.Directory = DEFAULT_DIRECTORY
        }</span>
}

func (l *LocalStorage) cleanTestName(testName string) string <span class="cov9" title="40">{
        // nested tests might contain slashes, replace them with underscores
        return strings.ReplaceAll(testName, "/", "_")
}</span>

// Store saves a test report as a JSON file in local storage.
// It organizes reports by test name and commit/tag, ensuring easy retrieval and management. 
// Returns the absolute path of the stored report or an error if the operation fails.
func (l *LocalStorage) Store(testName, commitOrTag string, report interface{}) (string, error) <span class="cov8" title="24">{
        l.defaultDirectoryIfEmpty()
        asJson, err := json.MarshalIndent(report, "", " ")
        if err != nil </span><span class="cov1" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="23">if _, err := os.Stat(l.Directory); os.IsNotExist(err) </span><span class="cov3" title="3">{
                if err := os.MkdirAll(l.Directory, 0755); err != nil </span><span class="cov1" title="1">{
                        return "", errors.Wrapf(err, "failed to create directory %s", l.Directory)
                }</span>
        }

        <span class="cov8" title="22">cleanTestName := l.cleanTestName(testName)
        reportFilePath := filepath.Join(l.Directory, fmt.Sprintf("%s-%s.json", cleanTestName, commitOrTag))
        reportFile, err := os.Create(reportFilePath)
        if err != nil </span><span class="cov2" title="2">{
                return "", errors.Wrapf(err, "failed to create file %s", reportFilePath)
        }</span>
        <span class="cov8" title="20">defer func() </span><span class="cov8" title="20">{ _ = reportFile.Close() }</span>()

        <span class="cov8" title="20">reader := bytes.NewReader(asJson)
        _, err = io.Copy(reportFile, reader)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrapf(err, "failed to write to file %s", reportFilePath)
        }</span>

        <span class="cov8" title="20">abs, err := filepath.Abs(reportFilePath)
        if err != nil </span><span class="cov0" title="0">{
                return reportFilePath, nil
        }</span>

        <span class="cov8" title="20">return abs, nil</span>
}

// Load retrieves a report from local storage based on the specified test name and optional commit or tag.
// It decodes the report into the provided interface, enabling users to access stored test results.
func (l *LocalStorage) Load(testName, commitOrTag string, report interface{}) error <span class="cov8" title="19">{
        l.defaultDirectoryIfEmpty()
        if testName == "" </span><span class="cov1" title="1">{
                return errors.New("test name is empty. Please set it and try again")
        }</span>

        <span class="cov7" title="18">cleanTestName := l.cleanTestName(testName)

        var ref string
        if commitOrTag == "" </span><span class="cov6" title="10">{
                entries, err := os.ReadDir(l.Directory)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to read storage directory")
                }</span>

                // Store both refs and file paths
                <span class="cov6" title="10">var refs []string
                filesByRef := make(map[string]string)
                for _, entry := range entries </span><span class="cov8" title="21">{
                        if !entry.IsDir() &amp;&amp; strings.Contains(entry.Name(), cleanTestName) </span><span class="cov7" title="15">{
                                parts := strings.Split(entry.Name(), "-")
                                if len(parts) == 2 </span><span class="cov7" title="15">{
                                        ref := strings.TrimSuffix(parts[len(parts)-1], ".json")
                                        refs = append(refs, ref)
                                        filesByRef[ref] = filepath.Join(l.Directory, entry.Name())
                                }</span> else<span class="cov0" title="0"> {
                                        return errors.Errorf("invalid file name: %s. Expected: %s-&lt;ref&gt;.json", entry.Name(), cleanTestName)
                                }</span>
                        }
                }

                <span class="cov6" title="10">if len(refs) == 0 </span><span class="cov2" title="2">{
                        return fmt.Errorf("no reports found in directory %s", l.Directory)
                }</span>

                <span class="cov5" title="8">if len(refs) &gt; 1 </span><span class="cov5" title="6">{
                        // Find git root
                        cmd := exec.Command("git", "rev-parse", "--show-toplevel")
                        cmd.Dir = l.Directory
                        out, err := cmd.Output()
                        if err != nil </span><span class="cov1" title="1">{
                                return errors.Wrap(err, "failed to find git root")
                        }</span>
                        <span class="cov4" title="5">gitRoot := strings.TrimSpace(string(out))

                        // Resolve all refs to commit hashes
                        resolvedRefs := make(map[string]string)
                        for _, ref := range refs </span><span class="cov6" title="11">{
                                cmd = exec.Command("git", "rev-parse", ref)
                                cmd.Dir = gitRoot
                                if out, err := cmd.Output(); err == nil </span><span class="cov5" title="7">{
                                        resolvedRefs[ref] = strings.TrimSpace(string(out))
                                }</span>
                        }

                        // Find latest among resolved commits
                        <span class="cov4" title="5">var commitRefs []string
                        for _, hash := range resolvedRefs </span><span class="cov5" title="7">{
                                commitRefs = append(commitRefs, hash)
                        }</span>

                        <span class="cov4" title="5">args := append([]string{"rev-list", "--topo-order", "--date-order", "--max-count=1"}, commitRefs...)
                        cmd = exec.Command("git", args...)
                        cmd.Dir = gitRoot
                        out, err = cmd.Output()
                        if err != nil </span><span class="cov2" title="2">{
                                return errors.Wrap(err, "failed to find latest reference")
                        }</span>
                        <span class="cov3" title="3">latestCommit := strings.TrimSpace(string(out))

                        // Find original ref for this commit
                        foundOriginal := false
                        for origRef, hash := range resolvedRefs </span><span class="cov4" title="4">{
                                if hash == latestCommit </span><span class="cov3" title="3">{
                                        ref = origRef
                                        foundOriginal = true
                                        break</span>
                                }
                        }

                        <span class="cov3" title="3">if !foundOriginal </span><span class="cov0" title="0">{
                                return fmt.Errorf("no file found for latest commit %s. This should never happen", latestCommit)
                        }</span>
                } else<span class="cov2" title="2"> {
                        ref = refs[0]
                }</span>
        } else<span class="cov5" title="8"> {
                ref = commitOrTag
        }</span>

        <span class="cov7" title="13">reportFilePath := filepath.Join(l.Directory, fmt.Sprintf("%s-%s.json", cleanTestName, ref))

        reportFile, err := os.Open(reportFilePath)
        if err != nil </span><span class="cov2" title="2">{
                return errors.Wrapf(err, "failed to open file %s", reportFilePath)
        }</span>

        <span class="cov6" title="11">decoder := json.NewDecoder(reportFile)
        if err := decoder.Decode(report); err != nil </span><span class="cov1" title="1">{
                return errors.Wrapf(err, "failed to decode file %s", reportFilePath)
        }</span>

        <span class="cov6" title="10">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
