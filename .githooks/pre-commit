#!/bin/bash
echo "*** Running pre-commit checks ***"

has_errors=0

printf "Checking 'go mod tidy'...\r"
cp go.mod go.mod.bak && cp go.sum go.sum.bak  # Backup the current go.mod and go.sum
go mod tidy
diff go.mod go.mod.bak > /dev/null
mod_diff=$?
diff go.sum go.sum.bak > /dev/null
sum_diff=$?

# Clean up backup files
rm go.mod.bak go.sum.bak

if [[ $mod_diff -ne 0 ]] || [[ $sum_diff -ne 0 ]];
then
    printf "Checking 'go mod tidy'... ❌\n"
    printf "'go mod tidy' has not been run on your changes.\n"
    printf "Run `go mod tidy` and commit the changes.\n"
    exit 1
else
    printf "Checking 'go mod tidy'... ✅\n"
fi

printf "Checking go.mod for local replacements...\r"

if grep -q "replace .* => /" "./go.mod"; then
    has_errors=1
    printf "Checking go.mod for local replacements... ❌\n"
    grep -n "replace .* => /" "./go.mod"
    printf "\e[31mYou forgot about a local replacement\e[0m\n"
else
    printf "Checking go.mod for local replacements... ✅\n"
fi

# Define the regex pattern for Ethereum keys
ethereum_key_pattern="(0x[a-fA-F0-9]{40})"
# Define the regex pattern for HTTP and WS URLs
url_pattern="(http|ws)(s)?:\/\/[^ \t\n\r]+"
# Check for staged files
staged_files=$(git diff --cached --name-only)

found_issue=0
printf "Checking for Ethereum keys...\r"
# Iterate through staged files
for file in $staged_files; do
    # Check if the file is tracked
    if git ls-files --error-unmatch "$file" &>/dev/null; then
        # Check if the file contains an Ethereum key
        if grep -q "$ethereum_key_pattern" "$file"; then
            has_errors=1
            found_issue=1
            printf "Checking for Ethereum keys... ❌\n"
            printf "\e[31mERROR: Ethereum key detected in file: $file\e[0m\n"
            grep -n "$ethereum_key_pattern" "$file"
            printf "\e[31mRemove the Ethereum key before committing.\e[0m\n"
        fi
    fi
done

if [[ $found_issue -eq 0 ]]; then
    printf "Checking for Ethereum keys... ✅\n"
fi

found_issue=0
printf "Checking for RPC URLs...\r"
for file in $staged_files; do
    # Check if the file is tracked
    if git ls-files --error-unmatch "$file" &>/dev/null; then
        # Check if the file contains a HTTP or WS URL
        if grep -q "$url_pattern" "$file"; then
            has_errors=1
            found_issue=1
            printf "Checking RPC URLs... ❌\n"
            printf "\e[31mERROR: HTTP/WS URL detected in file: $file\e[0m\n"
            grep -n "$url_pattern" "$file"
            printf "\e[31mPlease remove the URL before committing.\e[0m\n"
        fi
    fi
done

if [[ $found_issue -eq 0 ]]; then
    printf "Checking for RPC URLs... ✅\n"
fi

found_issue=0
printf "Checking for DEBUG:...\r"
for file in $staged_files; do
    # Check if the file is tracked
    if git ls-files --error-unmatch "$file" &>/dev/null; then
        if [[ "$file" == ".githooks/pre-commit" ]]; then # DEBUG: All up in here for good reason
            continue
        fi
        if grep -q "DEBUG: " "$file"; then
            has_errors=1
            found_issue=1
            printf "Checking for DEBUG:... ❌\n"
            printf "\e[31mERROR: 'DEBUG: ' detected in file: $file\e[0m\n"
            grep -n "DEBUG: " "$file"
            printf "\e[31mUn-Debug it\e[0m\n"
        fi
    fi
done

if [[ $found_issue -eq 0 ]]; then
    printf "Checking for DEBUG:... ✅\n"
fi

printf "Executing linters...\r"

golangci-lint run > /dev/null
linting_result=$?

if [[ $linting_result -ne 0 ]];
then
    printf "Executing linters... ❌\n"
    printf "Run `golangci-lint run -v` and fix them\n"

    exit 1
else
    printf "Executing linters... ✅\n"
fi

cd ./tools/gotestloghelper
golangci-lint run > /dev/null
linting_result=$?

if [[ $linting_result -ne 0 ]];
then
    printf "Executing linters... ❌\n"
    printf "Run `cd ./tools/gotestloghelper && golangci-lint run -v` and fix them\n"

    exit 1
else
    printf "Executing linters... ✅\n"
fi
cd -

if [[ $has_errors -eq 1 ]]; then
    printf "\e[31mPre-commit checks failed. Fix the errors before committing.\e[0m\n"
    exit 1
fi

printf "\e[32mPre-commit checks passed.\e[0m\n"
printf "\e[32mRemember to tap your Yubikey!\e[0m\n"

exit 0